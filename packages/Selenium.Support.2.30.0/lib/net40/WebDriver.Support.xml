<?xml version="1.0"?>
<doc>
  <assembly>
    <name>WebDriver.Support</name>
  </assembly>
  <members>
    <member name="T:OpenQA.Selenium.Support.Events.EventFiringWebDriver">
      <summary>
            A wrapper around an arbitrary WebDriver instance which supports registering for 
            events, e.g. for logging purposes.
            </summary>
    </member>
    <member name="T:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringNavigation">
      <summary>
            Provides a mechanism for Navigating with the driver.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringNavigation.#ctor(OpenQA.Selenium.Support.Events.EventFiringWebDriver)">
      <summary>
            Initializes a new instance of the EventFiringNavigation class
            </summary>
      <param name="driver">Driver in use</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringNavigation.Back">
      <summary>
            Move the browser back
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringNavigation.Forward">
      <summary>
            Move the browser forward
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringNavigation.GoToUrl(System.String)">
      <summary>
            Navigate to a url for your test
            </summary>
      <param name="url">String of where you want the browser to go to</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringNavigation.GoToUrl(System.Uri)">
      <summary>
            Navigate to a url for your test
            </summary>
      <param name="url">Uri object of where you want the browser to go to</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringNavigation.Refresh">
      <summary>
            Refresh the browser
            </summary>
    </member>
    <member name="T:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringOptions">
      <summary>
            Provides a mechanism for setting options needed for the driver during the test.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringOptions.#ctor(OpenQA.Selenium.Support.Events.EventFiringWebDriver)">
      <summary>
            Initializes a new instance of the EventFiringOptions class
            </summary>
      <param name="driver">Instance of the driver currently in use</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringOptions.Timeouts">
      <summary>
            Provides access to the timeouts defined for this driver.
            </summary>
      <returns>An object implementing the <see cref="T:OpenQA.Selenium.ITimeouts" /> interface.</returns>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringOptions.Cookies">
      <summary>
            Gets an object allowing the user to manipulate cookies on the page.
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringOptions.Window">
      <summary>
            Gets an object allowing the user to manipulate the currently-focused browser window.
            </summary>
      <remarks>"Currently-focused" is defined as the browser window having the window handle
            returned when IWebDriver.CurrentWindowHandle is called.</remarks>
    </member>
    <member name="T:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringTargetLocator">
      <summary>
            Provides a mechanism for finding elements on the page with locators.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringTargetLocator.#ctor(OpenQA.Selenium.Support.Events.EventFiringWebDriver)">
      <summary>
            Initializes a new instance of the EventFiringTargetLocator class
            </summary>
      <param name="driver">The driver that is currently in use</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringTargetLocator.Frame(System.Int32)">
      <summary>
            Move to a different frame using its index
            </summary>
      <param name="frameIndex">The index of the </param>
      <returns>A WebDriver instance that is currently in use</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringTargetLocator.Frame(System.String)">
      <summary>
            Move to different frame using its name
            </summary>
      <param name="frameName">name of the frame</param>
      <returns>A WebDriver instance that is currently in use</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringTargetLocator.Frame(OpenQA.Selenium.IWebElement)">
      <summary>
            Move to a frame element.
            </summary>
      <param name="frameElement">a previously found FRAME or IFRAME element.</param>
      <returns>A WebDriver instance that is currently in use.</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringTargetLocator.Window(System.String)">
      <summary>
            Change to the Window by passing in the name
            </summary>
      <param name="windowName">name of the window that you wish to move to</param>
      <returns>A WebDriver instance that is currently in use</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringTargetLocator.DefaultContent">
      <summary>
            Change the active frame to the default 
            </summary>
      <returns>Element of the default</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringTargetLocator.ActiveElement">
      <summary>
            Finds the active element on the page and returns it
            </summary>
      <returns>Element that is active</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringTargetLocator.Alert">
      <summary>
            Switches to the currently active modal dialog for this particular driver instance.
            </summary>
      <returns>A handle to the dialog.</returns>
    </member>
    <member name="T:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringTimeouts">
      <summary>
            Defines the interface through which the user can define timeouts.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringTimeouts.#ctor(OpenQA.Selenium.IOptions)">
      <summary>
            Initializes a new instance of the EventFiringTimeouts class
            </summary>
      <param name="options">The <see cref="T:OpenQA.Selenium.IOptions" /> object to wrap.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringTimeouts.ImplicitlyWait(System.TimeSpan)">
      <summary>
            Specifies the amount of time the driver should wait when searching for an
            element if it is not immediately present.
            </summary>
      <param name="timeToWait">A <see cref="T:System.TimeSpan" /> structure defining the amount of time to wait.</param>
      <returns>A self reference</returns>
      <remarks>
            When searching for a single element, the driver should poll the page
            until the element has been found, or this timeout expires before throwing
            a <see cref="T:OpenQA.Selenium.NoSuchElementException" />. When searching for multiple elements,
            the driver should poll the page until at least one element has been found
            or this timeout has expired.
            <para>
            Increasing the implicit wait timeout should be used judiciously as it
            will have an adverse effect on test run time, especially when used with
            slower location strategies like XPath.
            </para></remarks>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringTimeouts.SetScriptTimeout(System.TimeSpan)">
      <summary>
            Specifies the amount of time the driver should wait when executing JavaScript asynchronously.
            </summary>
      <param name="timeToWait">A <see cref="T:System.TimeSpan" /> structure defining the amount of time to wait.</param>
      <returns>A self reference</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringTimeouts.SetPageLoadTimeout(System.TimeSpan)">
      <summary>
            Specifies the amount of time the driver should wait for a page to load when setting the <see cref="P:OpenQA.Selenium.IWebDriver.Url" /> property.
            </summary>
      <param name="timeToWait">A <see cref="T:System.TimeSpan" /> structure defining the amount of time to wait.</param>
      <returns>A self reference</returns>
    </member>
    <member name="T:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringWebElement">
      <summary>
            EventFiringWebElement allows you to have access to specific items that are found on the page
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringWebElement.#ctor(OpenQA.Selenium.Support.Events.EventFiringWebDriver,OpenQA.Selenium.IWebElement)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringWebElement" /> class.
            </summary>
      <param name="driver">The <see cref="T:OpenQA.Selenium.Support.Events.EventFiringWebDriver" /> instance hosting this element.</param>
      <param name="element">The <see cref="T:OpenQA.Selenium.IWebElement" /> to wrap for event firing.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringWebElement.Clear">
      <summary>
            Method to clear the text out of an Input element
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringWebElement.SendKeys(System.String)">
      <summary>
            Method for sending native key strokes to the browser
            </summary>
      <param name="text">String containing what you would like to type onto the screen</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringWebElement.Submit">
      <summary>
            If this current element is a form, or an element within a form, then this will be submitted to the remote server. 
            If this causes the current page to change, then this method will block until the new page is loaded.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringWebElement.Click">
      <summary>
            Click this element. If this causes a new page to load, this method will block until 
            the page has loaded. At this point, you should discard all references to this element 
            and any further operations performed on this element will have undefined behavior unless
            you know that the element and the page will still be present. If this element is not 
            clickable, then this operation is a no-op since it's pretty common for someone to 
            accidentally miss  the target when clicking in Real Life
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringWebElement.GetAttribute(System.String)">
      <summary>
            If this current element is a form, or an element within a form, then this will be submitted to the remote server. If this causes the current page to change, then this method will block until the new page is loaded.
            </summary>
      <param name="attributeName">Attribute you wish to get details of</param>
      <returns>The attribute's current value or null if the value is not set.</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringWebElement.GetCssValue(System.String)">
      <summary>
            Method to return the value of a CSS Property
            </summary>
      <param name="propertyName">CSS property key</param>
      <returns>string value of the CSS property</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringWebElement.FindElement(OpenQA.Selenium.By)">
      <summary>
            Finds the first element in the page that matches the <see cref="T:OpenQA.Selenium.By" /> object
            </summary>
      <param name="by">By mechanism to find the element</param>
      <returns>IWebElement object so that you can interaction that object</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringWebElement.FindElements(OpenQA.Selenium.By)">
      <summary>
            Finds the elements on the page by using the <see cref="T:OpenQA.Selenium.By" /> object and returns a ReadOnlyCollection of the Elements on the page
            </summary>
      <param name="by">By mechanism to find the element</param>
      <returns>ReadOnlyCollection of IWebElement</returns>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringWebElement.WrappedElement">
      <summary>
            Gets the underlying wrapped <see cref="T:OpenQA.Selenium.IWebElement" />.
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringWebElement.TagName">
      <summary>
            Gets the DOM Tag of element
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringWebElement.Text">
      <summary>
            Gets the text from the element
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringWebElement.Enabled">
      <summary>
            Gets a value indicating whether an element is currently enabled
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringWebElement.Selected">
      <summary>
            Gets a value indicating whether this element is selected or not. This operation only applies to input elements such as checkboxes, options in a select and radio buttons.
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringWebElement.Location">
      <summary>
            Gets the Location of an element and returns a Point object
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringWebElement.Size">
      <summary>
            Gets the <see cref="P:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringWebElement.Size" /> of the element on the page
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringWebElement.Displayed">
      <summary>
            Gets a value indicating whether the element is currently being displayed
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.EventFiringWebDriver.EventFiringWebElement.ParentDriver">
      <summary>
            Gets the underlying EventFiringWebDriver for this element.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.#ctor(OpenQA.Selenium.IWebDriver)">
      <summary>
            Initializes a new instance of the EventFiringWebDriver class.
            </summary>
      <param name="parentDriver">The driver to register events for.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.Close">
      <summary>
            Close the current window, quitting the browser if it is the last window currently open.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.Quit">
      <summary>
            Quits this driver, closing every associated window.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.Manage">
      <summary>
            Instructs the driver to change its settings.
            </summary>
      <returns>An <see cref="T:OpenQA.Selenium.IOptions" /> object allowing the user to change
            the settings of the driver.</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.Navigate">
      <summary>
            Instructs the driver to navigate the browser to another location.
            </summary>
      <returns>An <see cref="T:OpenQA.Selenium.INavigation" /> object allowing the user to access 
            the browser's history and to navigate to a given URL.</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.SwitchTo">
      <summary>
            Instructs the driver to send future commands to a different frame or window.
            </summary>
      <returns>An <see cref="T:OpenQA.Selenium.ITargetLocator" /> object which can be used to select
            a frame or window.</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.FindElement(OpenQA.Selenium.By)">
      <summary>
            Find the first <see cref="T:OpenQA.Selenium.IWebElement" /> using the given method. 
            </summary>
      <param name="by">The locating mechanism to use.</param>
      <returns>The first matching <see cref="T:OpenQA.Selenium.IWebElement" /> on the current context.</returns>
      <exception cref="T:OpenQA.Selenium.NoSuchElementException">If no element matches the criteria.</exception>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.FindElements(OpenQA.Selenium.By)">
      <summary>
            Find all <see cref="T:OpenQA.Selenium.IWebElement">IWebElements</see> within the current context 
            using the given mechanism.
            </summary>
      <param name="by">The locating mechanism to use.</param>
      <returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> of all <see cref="T:OpenQA.Selenium.IWebElement">WebElements</see>
            matching the current criteria, or an empty list if nothing matches.</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.Dispose">
      <summary>
            Frees all managed and unmanaged resources used by this instance.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.ExecuteScript(System.String,System.Object[])">
      <summary>
            Executes JavaScript in the context of the currently selected frame or window.
            </summary>
      <param name="script">The JavaScript code to execute.</param>
      <param name="args">The arguments to the script.</param>
      <returns>The value returned by the script.</returns>
      <remarks>
        <para>
            The <see cref="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.ExecuteScript(System.String,System.Object[])" />method executes JavaScript in the context of 
            the currently selected frame or window. This means that "document" will refer 
            to the current document. If the script has a return value, then the following 
            steps will be taken:
            </para>
        <para>
          <list type="bullet">
            <item>
              <description>For an HTML element, this method returns a <see cref="T:OpenQA.Selenium.IWebElement" /></description>
            </item>
            <item>
              <description>For a number, a <see cref="T:System.Int64" /> is returned</description>
            </item>
            <item>
              <description>For a boolean, a <see cref="T:System.Boolean" /> is returned</description>
            </item>
            <item>
              <description>For all other cases a <see cref="T:System.String" /> is returned.</description>
            </item>
            <item>
              <description>For an array,we check the first element, and attempt to return a 
            <see cref="T:System.Collections.Generic.List`1" /> of that type, following the rules above. Nested lists are not
            supported.</description>
            </item>
            <item>
              <description>If the value is null or there is no return value,
            <see langword="null" /> is returned.</description>
            </item>
          </list>
        </para>
        <para>
            Arguments must be a number (which will be converted to a <see cref="T:System.Int64" />),
            a <see cref="T:System.Boolean" />, a <see cref="T:System.String" /> or a <see cref="T:OpenQA.Selenium.IWebElement" />.
            An exception will be thrown if the arguments do not meet these criteria. 
            The arguments will be made available to the JavaScript via the "arguments" magic 
            variable, as if the function were called via "Function.apply" 
            </para>
      </remarks>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.ExecuteAsyncScript(System.String,System.Object[])">
      <summary>
            Executes JavaScript asynchronously in the context of the currently selected frame or window.
            </summary>
      <param name="script">The JavaScript code to execute.</param>
      <param name="args">The arguments to the script.</param>
      <returns>The value returned by the script.</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.GetScreenshot">
      <summary>
            Gets a <see cref="T:OpenQA.Selenium.Screenshot" /> object representing the image of the page on the screen.
            </summary>
      <returns>A <see cref="T:OpenQA.Selenium.Screenshot" /> object containing the image.</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.Dispose(System.Boolean)">
      <summary>
            Frees all managed and, optionally, unmanaged resources used by this instance.
            </summary>
      <param name="disposing">
        <see langword="true" /> to dispose of only managed resources;
            <see langword="false" /> to dispose of managed and unmanaged resources.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.OnNavigating(OpenQA.Selenium.Support.Events.WebDriverNavigationEventArgs)">
      <summary>
            Raises the <see cref="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.Navigating" /> event.
            </summary>
      <param name="e">A <see cref="T:OpenQA.Selenium.Support.Events.WebDriverNavigationEventArgs" /> that contains the event data.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.OnNavigated(OpenQA.Selenium.Support.Events.WebDriverNavigationEventArgs)">
      <summary>
            Raises the <see cref="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.Navigated" /> event.
            </summary>
      <param name="e">A <see cref="T:OpenQA.Selenium.Support.Events.WebDriverNavigationEventArgs" /> that contains the event data.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.OnNavigatingBack(OpenQA.Selenium.Support.Events.WebDriverNavigationEventArgs)">
      <summary>
            Raises the <see cref="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.NavigatingBack" /> event.
            </summary>
      <param name="e">A <see cref="T:OpenQA.Selenium.Support.Events.WebDriverNavigationEventArgs" /> that contains the event data.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.OnNavigatedBack(OpenQA.Selenium.Support.Events.WebDriverNavigationEventArgs)">
      <summary>
            Raises the <see cref="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.NavigatedBack" /> event.
            </summary>
      <param name="e">A <see cref="T:OpenQA.Selenium.Support.Events.WebDriverNavigationEventArgs" /> that contains the event data.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.OnNavigatingForward(OpenQA.Selenium.Support.Events.WebDriverNavigationEventArgs)">
      <summary>
            Raises the <see cref="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.NavigatingForward" /> event.
            </summary>
      <param name="e">A <see cref="T:OpenQA.Selenium.Support.Events.WebDriverNavigationEventArgs" /> that contains the event data.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.OnNavigatedForward(OpenQA.Selenium.Support.Events.WebDriverNavigationEventArgs)">
      <summary>
            Raises the <see cref="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.NavigatedForward" /> event.
            </summary>
      <param name="e">A <see cref="T:OpenQA.Selenium.Support.Events.WebDriverNavigationEventArgs" /> that contains the event data.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.OnElementClicking(OpenQA.Selenium.Support.Events.WebElementEventArgs)">
      <summary>
            Raises the <see cref="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.ElementClicking" /> event.
            </summary>
      <param name="e">A <see cref="T:OpenQA.Selenium.Support.Events.WebElementEventArgs" /> that contains the event data.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.OnElementClicked(OpenQA.Selenium.Support.Events.WebElementEventArgs)">
      <summary>
            Raises the <see cref="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.ElementClicked" /> event.
            </summary>
      <param name="e">A <see cref="T:OpenQA.Selenium.Support.Events.WebElementEventArgs" /> that contains the event data.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.OnElementValueChanging(OpenQA.Selenium.Support.Events.WebElementEventArgs)">
      <summary>
            Raises the <see cref="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.ElementValueChanging" /> event.
            </summary>
      <param name="e">A <see cref="T:OpenQA.Selenium.Support.Events.WebElementEventArgs" /> that contains the event data.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.OnElementValueChanged(OpenQA.Selenium.Support.Events.WebElementEventArgs)">
      <summary>
            Raises the <see cref="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.ElementValueChanged" /> event.
            </summary>
      <param name="e">A <see cref="T:OpenQA.Selenium.Support.Events.WebElementEventArgs" /> that contains the event data.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.OnFindingElement(OpenQA.Selenium.Support.Events.FindElementEventArgs)">
      <summary>
            Raises the <see cref="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.FindingElement" /> event.
            </summary>
      <param name="e">A <see cref="T:OpenQA.Selenium.Support.Events.FindElementEventArgs" /> that contains the event data.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.OnFindElementCompleted(OpenQA.Selenium.Support.Events.FindElementEventArgs)">
      <summary>
            Raises the <see cref="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.FindElementCompleted" /> event.
            </summary>
      <param name="e">A <see cref="T:OpenQA.Selenium.Support.Events.FindElementEventArgs" /> that contains the event data.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.OnScriptExecuting(OpenQA.Selenium.Support.Events.WebDriverScriptEventArgs)">
      <summary>
            Raises the <see cref="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.ScriptExecuting" /> event.
            </summary>
      <param name="e">A <see cref="T:OpenQA.Selenium.Support.Events.WebDriverScriptEventArgs" /> that contains the event data.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.OnScriptExecuted(OpenQA.Selenium.Support.Events.WebDriverScriptEventArgs)">
      <summary>
            Raises the <see cref="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.ScriptExecuted" /> event.
            </summary>
      <param name="e">A <see cref="T:OpenQA.Selenium.Support.Events.WebDriverScriptEventArgs" /> that contains the event data.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.EventFiringWebDriver.OnException(OpenQA.Selenium.Support.Events.WebDriverExceptionEventArgs)">
      <summary>
            Raises the <see cref="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.ExceptionThrown" /> event.
            </summary>
      <param name="e">A <see cref="T:OpenQA.Selenium.Support.Events.WebDriverExceptionEventArgs" /> that contains the event data.</param>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.EventFiringWebDriver.WrappedDriver">
      <summary>
            Gets the <see cref="T:OpenQA.Selenium.IWebDriver" /> wrapped by this EventsFiringWebDriver instance.
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.EventFiringWebDriver.Url">
      <summary>
            Gets or sets the URL the browser is currently displaying.
            </summary>
      <remarks>
            Setting the <see cref="P:OpenQA.Selenium.Support.Events.EventFiringWebDriver.Url" /> property will load a new web page in the current browser window. 
            This is done using an HTTP GET operation, and the method will block until the 
            load is complete. This will follow redirects issued either by the server or 
            as a meta-redirect from within the returned HTML. Should a meta-redirect "rest"
            for any duration of time, it is best to wait until this timeout is over, since 
            should the underlying page change while your test is executing the results of 
            future calls against this interface will be against the freshly loaded page. 
            </remarks>
      <seealso cref="M:OpenQA.Selenium.INavigation.GoToUrl(System.String)" />
      <seealso cref="M:OpenQA.Selenium.INavigation.GoToUrl(System.Uri)" />
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.EventFiringWebDriver.Title">
      <summary>
            Gets the title of the current browser window.
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.EventFiringWebDriver.PageSource">
      <summary>
            Gets the source of the page last loaded by the browser.
            </summary>
      <remarks>
            If the page has been modified after loading (for example, by JavaScript) 
            there is no guarantee that the returned text is that of the modified page. 
            Please consult the documentation of the particular driver being used to 
            determine whether the returned text reflects the current state of the page 
            or the text last sent by the web server. The page source returned is a 
            representation of the underlying DOM: do not expect it to be formatted 
            or escaped in the same way as the response sent from the web server. 
            </remarks>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.EventFiringWebDriver.CurrentWindowHandle">
      <summary>
            Gets the current window handle, which is an opaque handle to this 
            window that uniquely identifies it within this driver instance.
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.EventFiringWebDriver.WindowHandles">
      <summary>
            Gets the window handles of open browser windows.
            </summary>
    </member>
    <member name="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.Navigating">
      <summary>
            Fires before the driver begins navigation.
            </summary>
    </member>
    <member name="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.Navigated">
      <summary>
            Fires after the driver completes navigation
            </summary>
    </member>
    <member name="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.NavigatingBack">
      <summary>
            Fires before the driver begins navigation back one entry in the browser history list.
            </summary>
    </member>
    <member name="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.NavigatedBack">
      <summary>
            Fires after the driver completes navigation back one entry in the browser history list.
            </summary>
    </member>
    <member name="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.NavigatingForward">
      <summary>
            Fires before the driver begins navigation forward one entry in the browser history list.
            </summary>
    </member>
    <member name="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.NavigatedForward">
      <summary>
            Fires after the driver completes navigation forward one entry in the browser history list.
            </summary>
    </member>
    <member name="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.ElementClicking">
      <summary>
            Fires before the driver clicks on an element.
            </summary>
    </member>
    <member name="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.ElementClicked">
      <summary>
            Fires after the driver has clicked on an element.
            </summary>
    </member>
    <member name="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.ElementValueChanging">
      <summary>
            Fires before the driver changes the value of an element via Clear(), SendKeys() or Toggle().
            </summary>
    </member>
    <member name="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.ElementValueChanged">
      <summary>
            Fires after the driver has changed the value of an element via Clear(), SendKeys() or Toggle().
            </summary>
    </member>
    <member name="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.FindingElement">
      <summary>
            Fires before the driver starts to find an element.
            </summary>
    </member>
    <member name="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.FindElementCompleted">
      <summary>
            Fires after the driver completes finding an element.
            </summary>
    </member>
    <member name="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.ScriptExecuting">
      <summary>
            Fires before a script is executed.
            </summary>
    </member>
    <member name="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.ScriptExecuted">
      <summary>
            Fires after a script is executed.
            </summary>
    </member>
    <member name="E:OpenQA.Selenium.Support.Events.EventFiringWebDriver.ExceptionThrown">
      <summary>
            Fires when an exception is thrown.
            </summary>
    </member>
    <member name="T:OpenQA.Selenium.Support.Events.FindElementEventArgs">
      <summary>
            Provides data for events related to finding elements.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.FindElementEventArgs.#ctor(OpenQA.Selenium.IWebDriver,OpenQA.Selenium.By)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.Events.FindElementEventArgs" /> class.
            </summary>
      <param name="driver">The WebDriver instance used in finding elements.</param>
      <param name="method">The <see cref="T:OpenQA.Selenium.By" /> object containing the method used to find elements</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.FindElementEventArgs.#ctor(OpenQA.Selenium.IWebDriver,OpenQA.Selenium.IWebElement,OpenQA.Selenium.By)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.Events.FindElementEventArgs" /> class.
            </summary>
      <param name="driver">The WebDriver instance used in finding elements.</param>
      <param name="element">The parent element used as the context for the search.</param>
      <param name="method">The <see cref="T:OpenQA.Selenium.By" /> object containing the method used to find elements.</param>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.FindElementEventArgs.Driver">
      <summary>
            Gets the WebDriver instance used in finding elements.
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.FindElementEventArgs.Element">
      <summary>
            Gets the parent element used as the context for the search.
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.FindElementEventArgs.FindMethod">
      <summary>
            Gets the <see cref="T:OpenQA.Selenium.By" /> object containing the method used to find elements.
            </summary>
    </member>
    <member name="T:OpenQA.Selenium.Support.Events.WebDriverExceptionEventArgs">
      <summary>
            Provides data for events relating to exception handling.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.WebDriverExceptionEventArgs.#ctor(OpenQA.Selenium.IWebDriver,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.Events.WebDriverExceptionEventArgs" /> class.
            </summary>
      <param name="driver">The WebDriver instance throwing the exception.</param>
      <param name="thrownException">The exception thrown by the driver.</param>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.WebDriverExceptionEventArgs.ThrownException">
      <summary>
            Gets the exception thrown by the driver.
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.WebDriverExceptionEventArgs.Driver">
      <summary>
            Gets the WebDriver instance .
            </summary>
    </member>
    <member name="T:OpenQA.Selenium.Support.Events.WebDriverNavigationEventArgs">
      <summary>
            Provides data for events relating to navigation.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.WebDriverNavigationEventArgs.#ctor(OpenQA.Selenium.IWebDriver)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.Events.WebDriverNavigationEventArgs" /> class.
            </summary>
      <param name="driver">The WebDriver instance used in navigation.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.WebDriverNavigationEventArgs.#ctor(OpenQA.Selenium.IWebDriver,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.Events.WebDriverNavigationEventArgs" /> class.
            </summary>
      <param name="driver">The WebDriver instance used in navigation.</param>
      <param name="url">The URL navigated to by the driver.</param>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.WebDriverNavigationEventArgs.Url">
      <summary>
            Gets the URL navigated to by the driver.
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.WebDriverNavigationEventArgs.Driver">
      <summary>
            Gets the WebDriver instance used in navigation.
            </summary>
    </member>
    <member name="T:OpenQA.Selenium.Support.Events.WebDriverScriptEventArgs">
      <summary>
            Provides data for events relating to executing JavaScript.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.WebDriverScriptEventArgs.#ctor(OpenQA.Selenium.IWebDriver,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.Events.WebDriverScriptEventArgs" /> class.
            </summary>
      <param name="driver">The WebDriver instance used to execute the script.</param>
      <param name="script">The script executed by the driver.</param>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.WebDriverScriptEventArgs.Driver">
      <summary>
            Gets the WebDriver instance used to execute the script.
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.WebDriverScriptEventArgs.Script">
      <summary>
            Gets the script executed by the driver.
            </summary>
    </member>
    <member name="T:OpenQA.Selenium.Support.Events.WebElementEventArgs">
      <summary>
            Provides data for events relating to elements.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.Events.WebElementEventArgs.#ctor(OpenQA.Selenium.IWebDriver,OpenQA.Selenium.IWebElement)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.Events.WebElementEventArgs" /> class.
            </summary>
      <param name="driver">The WebDriver instance used for the action.</param>
      <param name="element">The element used for the action.</param>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.WebElementEventArgs.Driver">
      <summary>
            Gets the WebDriver instance used for the action.
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.Events.WebElementEventArgs.Element">
      <summary>
            Gets the element used for the action.
            </summary>
    </member>
    <member name="T:OpenQA.Selenium.Support.PageObjects.ByChained">
      <summary>
            Mechanism used to locate elements within a document using a series of other lookups.  This class
            will find all DOM elements that matches each of the locators in sequence
            </summary>
      <example>
            The following code will will find all elements that match by2 and appear under an element that matches
            by1.
            <code>
            driver.findElements(new ByChained(by1, by2))
            </code></example>
    </member>
    <member name="M:OpenQA.Selenium.Support.PageObjects.ByChained.#ctor(OpenQA.Selenium.By[])">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.PageObjects.ByChained" /> class with one or more <see cref="T:OpenQA.Selenium.By" /> objects.
            </summary>
      <param name="bys">One or more <see cref="T:OpenQA.Selenium.By" /> references</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.PageObjects.ByChained.FindElement(OpenQA.Selenium.ISearchContext)">
      <summary>
            Find a single element.
            </summary>
      <param name="context">Context used to find the element.</param>
      <returns>The element that matches</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.PageObjects.ByChained.FindElements(OpenQA.Selenium.ISearchContext)">
      <summary>
            Finds many elements
            </summary>
      <param name="context">Context used to find the element.</param>
      <returns>A readonly collection of elements that match.</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.PageObjects.ByChained.ToString">
      <summary>
            Writes out a comma separated list of the <see cref="T:OpenQA.Selenium.By" /> objects used in the chain.
            </summary>
      <returns>Converts the value of this instance to a <see cref="T:System.String" /></returns>
    </member>
    <member name="T:OpenQA.Selenium.Support.PageObjects.ByFactory">
      <summary>
            Provides instances of the <see cref="T:OpenQA.Selenium.By" /> object to the attributes.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.PageObjects.ByFactory.From(OpenQA.Selenium.Support.PageObjects.FindsByAttribute)">
      <summary>
            Gets an instance of the <see cref="T:OpenQA.Selenium.By" /> class based on the specified attribute.
            </summary>
      <param name="attribute">The <see cref="T:OpenQA.Selenium.Support.PageObjects.FindsByAttribute" /> describing how to find the element.</param>
      <returns>An instance of the <see cref="T:OpenQA.Selenium.By" /> class.</returns>
    </member>
    <member name="T:OpenQA.Selenium.Support.PageObjects.CacheLookupAttribute">
      <summary>
            Marks the element so that lookups to the browser page are cached. This class cannot be inherited.
            </summary>
    </member>
    <member name="T:OpenQA.Selenium.Support.PageObjects.FindsByAttribute">
      <summary>
            Marks program elements with methods by which to find a corresponding element on the page. Used
            in conjunction with the <see cref="T:OpenQA.Selenium.Support.PageObjects.PageFactory" />, it allows you to quickly create Page Objects.
            </summary>
      <remarks>
        <para>
            You can use this attribute by specifying the <see cref="P:OpenQA.Selenium.Support.PageObjects.FindsByAttribute.How" /> and <see cref="P:OpenQA.Selenium.Support.PageObjects.FindsByAttribute.Using" /> properties
            to indicate how to find the elements. This attribute can be used to decorate fields and properties
            in your Page Object classes. The <see cref="T:System.Type" /> of the field or property must be either
            <see cref="T:OpenQA.Selenium.IWebElement" /> or IList{IWebElement}. Any other type will throw an
            <see cref="T:System.ArgumentException" /> when <see cref="M:OpenQA.Selenium.Support.PageObjects.PageFactory.InitElements(OpenQA.Selenium.ISearchContext,System.Object)" /> is called.
            </para>
        <para>
          <code>
            [FindsBy(How = How.Name, Using = "myElementName")]
            public IWebElement foundElement;
            
            [FindsBy(How = How.TagName, Using = "a")]
            public IList{IWebElement} allLinks;
            </code>
        </para>
        <para>
            You can also use multiple instances of this attribute to find an element that may meet
            one of multiple criteria. When using multiple instances, you can specify the order in 
            which the criteria is matched by using the <see cref="P:OpenQA.Selenium.Support.PageObjects.FindsByAttribute.Priority" /> property.
            </para>
        <para>
          <code>
            // Will find the element with the name attribute matching the first of "anElementName"
            // or "differentElementName".
            [FindsBy(How = How.Name, Using = "anElementName", Priority = 0)]
            [FindsBy(How = How.Name, Using = "differentElementName", Priority = 1)]
            public IWebElement thisElement;
            </code>
        </para>
      </remarks>
    </member>
    <member name="M:OpenQA.Selenium.Support.PageObjects.FindsByAttribute.op_Equality(OpenQA.Selenium.Support.PageObjects.FindsByAttribute,OpenQA.Selenium.Support.PageObjects.FindsByAttribute)">
      <summary>
            Determines if two <see cref="T:OpenQA.Selenium.Support.PageObjects.FindsByAttribute" /> instances are equal.
            </summary>
      <param name="one">One instance to compare.</param>
      <param name="two">The other instance to compare.</param>
      <returns>
        <see langword="true" /> if the two instances are equal; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.PageObjects.FindsByAttribute.op_Inequality(OpenQA.Selenium.Support.PageObjects.FindsByAttribute,OpenQA.Selenium.Support.PageObjects.FindsByAttribute)">
      <summary>
            Determines if two <see cref="T:OpenQA.Selenium.Support.PageObjects.FindsByAttribute" /> instances are unequal.
            </summary>s
            <param name="one">One instance to compare.</param><param name="two">The other instance to compare.</param><returns><see langword="true" /> if the two instances are not equal; otherwise, <see langword="false" />.</returns></member>
    <member name="M:OpenQA.Selenium.Support.PageObjects.FindsByAttribute.op_GreaterThan(OpenQA.Selenium.Support.PageObjects.FindsByAttribute,OpenQA.Selenium.Support.PageObjects.FindsByAttribute)">
      <summary>
            Determines if one <see cref="T:OpenQA.Selenium.Support.PageObjects.FindsByAttribute" /> instance is greater than another.
            </summary>
      <param name="one">One instance to compare.</param>
      <param name="two">The other instance to compare.</param>
      <returns>
        <see langword="true" /> if the first instance is greater than the second; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.PageObjects.FindsByAttribute.op_LessThan(OpenQA.Selenium.Support.PageObjects.FindsByAttribute,OpenQA.Selenium.Support.PageObjects.FindsByAttribute)">
      <summary>
            Determines if one <see cref="T:OpenQA.Selenium.Support.PageObjects.FindsByAttribute" /> instance is less than another.
            </summary>
      <param name="one">One instance to compare.</param>
      <param name="two">The other instance to compare.</param>
      <returns>
        <see langword="true" /> if the first instance is less than the second; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.PageObjects.FindsByAttribute.CompareTo(System.Object)">
      <summary>
            Compares the current instance with another object of the same type and returns an 
            integer that indicates whether the current instance precedes, follows, or occurs 
            in the same position in the sort order as the other object.
            </summary>
      <param name="obj">An object to compare with this instance.</param>
      <returns>A value that indicates the relative order of the objects being compared. The return value has these meanings:
            <list type="table"><listheader>Value</listheader><listheader>Meaning</listheader><item><description>Less than zero</description><description>This instance precedes <paramref name="obj" /> in the sort order.</description></item><item><description>Zero</description><description>This instance occurs in the same position in the sort order as <paramref name="obj" />.</description></item><item><description>Greater than zero</description><description>This instance follows <paramref name="obj" /> in the sort order. </description></item></list></returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.PageObjects.FindsByAttribute.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object">Object</see> is equal 
            to the current <see cref="T:System.Object">Object</see>.
            </summary>
      <param name="obj">The <see cref="T:System.Object">Object</see> to compare with the 
            current <see cref="T:System.Object">Object</see>.</param>
      <returns>
        <see langword="true" /> if the specified <see cref="T:System.Object">Object</see>
            is equal to the current <see cref="T:System.Object">Object</see>; otherwise,
            <see langword="false" />.</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.PageObjects.FindsByAttribute.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>A hash code for the current <see cref="T:System.Object">Object</see>.</returns>
    </member>
    <member name="P:OpenQA.Selenium.Support.PageObjects.FindsByAttribute.How">
      <summary>
            Gets or sets the method used to look up the element
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.PageObjects.FindsByAttribute.Using">
      <summary>
            Gets or sets the value to lookup by (i.e. for How.Name, the actual name to look up)
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.PageObjects.FindsByAttribute.Priority">
      <summary>
            Gets or sets a value indicating where this attribute should be evaluated relative to other instances
            of this attribute decorating the same class member.
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.PageObjects.FindsByAttribute.CustomFinderType">
      <summary>
            Gets or sets a value indicating the <see cref="T:System.Type" /> of the custom finder. The custom finder must
            descend from the <see cref="T:OpenQA.Selenium.By" /> class, and expose a public constructor that takes a <see cref="T:System.String" />
            argument.
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.PageObjects.FindsByAttribute.Finder">
      <summary>
            Gets or sets an explicit <see cref="T:OpenQA.Selenium.By" /> object to find by.
            Setting this property takes precedence over setting the How or Using properties.
            </summary>
    </member>
    <member name="T:OpenQA.Selenium.Support.PageObjects.How">
      <summary>
            Provides the lookup methods for the FindsBy attribute (for using in PageObjects)
            </summary>
    </member>
    <member name="F:OpenQA.Selenium.Support.PageObjects.How.Id">
      <summary>
            Finds by <see cref="M:OpenQA.Selenium.By.Id(System.String)" /></summary>
    </member>
    <member name="F:OpenQA.Selenium.Support.PageObjects.How.Name">
      <summary>
            Finds by <see cref="M:OpenQA.Selenium.By.Name(System.String)" /></summary>
    </member>
    <member name="F:OpenQA.Selenium.Support.PageObjects.How.TagName">
      <summary>
            Finds by <see cref="M:OpenQA.Selenium.By.TagName(System.String)" /></summary>
    </member>
    <member name="F:OpenQA.Selenium.Support.PageObjects.How.ClassName">
      <summary>
            Finds by <see cref="M:OpenQA.Selenium.By.ClassName(System.String)" /></summary>
    </member>
    <member name="F:OpenQA.Selenium.Support.PageObjects.How.CssSelector">
      <summary>
            Finds by <see cref="M:OpenQA.Selenium.By.CssSelector(System.String)" /></summary>
    </member>
    <member name="F:OpenQA.Selenium.Support.PageObjects.How.LinkText">
      <summary>
            Finds by <see cref="M:OpenQA.Selenium.By.LinkText(System.String)" /></summary>
    </member>
    <member name="F:OpenQA.Selenium.Support.PageObjects.How.PartialLinkText">
      <summary>
            Finds by <see cref="M:OpenQA.Selenium.By.PartialLinkText(System.String)" /></summary>
    </member>
    <member name="F:OpenQA.Selenium.Support.PageObjects.How.XPath">
      <summary>
            Finds by <see cref="M:OpenQA.Selenium.By.XPath(System.String)" /></summary>
    </member>
    <member name="F:OpenQA.Selenium.Support.PageObjects.How.Custom">
      <summary>
            Finds by a custom <see cref="T:OpenQA.Selenium.By" /> implementation.
            </summary>
    </member>
    <member name="T:OpenQA.Selenium.Support.PageObjects.PageFactory">
      <summary>
            Provides the ability to produce Page Objects modeling a page. This class cannot be inherited.
            </summary>
    </member>
    <member name="T:OpenQA.Selenium.Support.PageObjects.PageFactory.ProxiedWebElementCollectionInterceptor">
      <summary>
            Provides an interceptor to assist in creating the Page Object. This class cannot be inherited.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.PageObjects.PageFactory.ProxiedWebElementCollectionInterceptor.#ctor(OpenQA.Selenium.ISearchContext,System.Collections.Generic.IEnumerable{OpenQA.Selenium.By},System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.PageObjects.PageFactory.ProxiedWebElementCollectionInterceptor" /> class.
            </summary>
      <param name="searchContext">The driver used to search for elements.</param>
      <param name="bys">The list of methods by which to search for the elements.</param>
      <param name="cache">
        <see langword="true" /> to cache the lookup to the element; otherwise, <see langword="false" />.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.PageObjects.PageFactory.ProxiedWebElementCollectionInterceptor.Intercept(Castle.DynamicProxy.IInvocation)">
      <summary>
            Intercepts calls to methods on the class.
            </summary>
      <param name="invocation">An IInvocation object describing the actual implementation.</param>
    </member>
    <member name="T:OpenQA.Selenium.Support.PageObjects.PageFactory.ProxiedWebElementInterceptor">
      <summary>
            Provides an interceptor to assist in creating the Page Object. This class cannot be inherited.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.PageObjects.PageFactory.ProxiedWebElementInterceptor.#ctor(OpenQA.Selenium.ISearchContext,System.Collections.Generic.IEnumerable{OpenQA.Selenium.By},System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.PageObjects.PageFactory.ProxiedWebElementInterceptor" /> class.
            </summary>
      <param name="searchContext">The driver used to search for element.</param>
      <param name="bys">The list of methods by which to search for the elements.</param>
      <param name="cache">
        <see langword="true" /> to cache the lookup to the element; otherwise, <see langword="false" />.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.PageObjects.PageFactory.ProxiedWebElementInterceptor.Intercept(Castle.DynamicProxy.IInvocation)">
      <summary>
            Intercepts calls to methods on the class.
            </summary>
      <param name="invocation">An IInvocation object describing the actual implementation.</param>
    </member>
    <member name="P:OpenQA.Selenium.Support.PageObjects.PageFactory.ProxiedWebElementInterceptor.WrappedElement">
      <summary>
            Gets the element wrapped by this <see cref="T:OpenQA.Selenium.Support.PageObjects.PageFactory.ProxiedWebElementInterceptor" />.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.PageObjects.PageFactory.#ctor">
      <summary>
            Prevents a default instance of the PageFactory class from being created.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.PageObjects.PageFactory.InitElements``1(OpenQA.Selenium.IWebDriver)">
      <summary>
            Initializes the elements in the Page Object with the given type.
            </summary>
      <typeparam name="T">The <see cref="T:System.Type" /> of the Page Object class.</typeparam>
      <param name="driver">The <see cref="T:OpenQA.Selenium.IWebDriver" /> instance used to populate the page.</param>
      <returns>An instance of the Page Object class with the elements initialized.</returns>
      <remarks>
            The class used in the <typeparamref name="T" /> argument must have a public constructor
            that takes a single argument of type <see cref="T:OpenQA.Selenium.IWebDriver" />. This helps to enforce
            best practices of the Page Object pattern, and encapsulates the driver into the Page
            Object so that it can have no external WebDriver dependencies.
            </remarks>
      <exception cref="T:System.ArgumentException">
            thrown if no constructor to the class can be found with a single IWebDriver argument
            <para>-or-</para>
            if a field or property decorated with the <see cref="T:OpenQA.Selenium.Support.PageObjects.FindsByAttribute" /> is not of type
            <see cref="T:OpenQA.Selenium.IWebElement" /> or IList{IWebElement}.
            </exception>
    </member>
    <member name="M:OpenQA.Selenium.Support.PageObjects.PageFactory.InitElements(OpenQA.Selenium.ISearchContext,System.Object)">
      <summary>
            Initializes the elements in the Page Object.
            </summary>
      <param name="driver">The driver used to find elements on the page.</param>
      <param name="page">The Page Object to be populated with elements.</param>
      <exception cref="T:System.ArgumentException">
            thrown if a field or property decorated with the <see cref="T:OpenQA.Selenium.Support.PageObjects.FindsByAttribute" /> is not of type
            <see cref="T:OpenQA.Selenium.IWebElement" /> or IList{IWebElement}.
            </exception>
    </member>
    <member name="T:OpenQA.Selenium.Support.PageObjects.WebElementProxyComparer">
      <summary>
            Provides comparison of web elements that have been wrapped by a proxy.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.PageObjects.WebElementProxyComparer.Equals(System.Object)">
      <summary>
            Gets a value indicating whether two elements are equal.
            </summary>
      <param name="obj">An object representing a second element.</param>
      <returns>
        <see langword="true" /> if the objects are equal; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.PageObjects.WebElementProxyComparer.GetHashCode">
      <summary>
            Gets a unique hash code for this object.
            </summary>
      <returns>A unique hash code for this object.</returns>
    </member>
    <member name="T:OpenQA.Selenium.Support.UI.IWait`1">
      <summary>
            Interface describing a class designed to wait for a condition.
            </summary>
      <typeparam name="TSource">The type of object used to detect the condition.</typeparam>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.IWait`1.IgnoreExceptionTypes(System.Type[])">
      <summary>
            Configures this instance to ignore specific types of exceptions while waiting for a condition.
            Any exceptions not whitelisted will be allowed to propagate, terminating the wait.
            </summary>
      <param name="exceptionTypes">The types of exceptions to ignore.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.IWait`1.Until``1(System.Func{`0,``0})">
      <summary>
            Waits until a condition is true or times out.
            </summary>
      <typeparam name="TResult">The type of result to expect from the condition.</typeparam>
      <param name="condition">A delegate taking a TSource as its parameter, and returning a TResult.</param>
      <returns>If TResult is a boolean, the method returns <see langword="true" /> when the condition is true, and <see langword="false" /> otherwise.
            If TResult is an object, the method returns the object when the condition evaluates to a value other than <see langword="null" />.</returns>
      <exception cref="T:System.ArgumentException">Thrown when TResult is not boolean or an object type.</exception>
    </member>
    <member name="P:OpenQA.Selenium.Support.UI.IWait`1.Timeout">
      <summary>
            Gets or sets how long to wait for the evaluated condition to be true.
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.UI.IWait`1.PollingInterval">
      <summary>
            Gets or sets how often the condition should be evaluated.
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.UI.IWait`1.Message">
      <summary>
            Gets or sets the message to be displayed when time expires.
            </summary>
    </member>
    <member name="T:OpenQA.Selenium.Support.UI.DefaultWait`1">
      <summary>
            An implementation of the <see cref="T:OpenQA.Selenium.Support.UI.IWait`1" /> interface that may have its timeout and polling interval
            configured on the fly.
            </summary>
      <typeparam name="T">The type of object on which the wait it to be applied.</typeparam>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.DefaultWait`1.#ctor(`0)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.UI.DefaultWait`1" /> class.
            </summary>
      <param name="input">The input value to pass to the evaluated conditions.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.DefaultWait`1.#ctor(`0,OpenQA.Selenium.Support.UI.IClock)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.UI.DefaultWait`1" /> class.
            </summary>
      <param name="input">The input value to pass to the evaluated conditions.</param>
      <param name="clock">The clock to use when measuring the timeout.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.DefaultWait`1.IgnoreExceptionTypes(System.Type[])">
      <summary>
            Configures this instance to ignore specific types of exceptions while waiting for a condition.
            Any exceptions not whitelisted will be allowed to propagate, terminating the wait.
            </summary>
      <param name="exceptionTypes">The types of exceptions to ignore.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.DefaultWait`1.Until``1(System.Func{`0,``0})">
      <summary>
            Repeatedly applies this instance's input value to the given function until one of the following
            occurs:
            <para><list type="bullet"><item>the function returns neither null nor false</item><item>the function throws an exception that is not in the list of ignored exception types</item><item>the timeout expires</item></list></para></summary>
      <typeparam name="TResult">The delegate's expected return type.</typeparam>
      <param name="condition">A delegate taking an object of type T as its parameter, and returning a TResult.</param>
      <returns>The delegate's return value.</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.DefaultWait`1.ThrowTimeoutException(System.String,System.Exception)">
      <summary>
            Throws a <see cref="T:OpenQA.Selenium.WebDriverTimeoutException" /> with the given message.
            </summary>
      <param name="exceptionMessage">The message of the exception.</param>
      <param name="lastException">The last exception thrown by the condition.</param>
      <remarks>This method may be overridden to throw an exception that is
            idiomatic for a particular test infrastructure.</remarks>
    </member>
    <member name="P:OpenQA.Selenium.Support.UI.DefaultWait`1.Timeout">
      <summary>
            Gets or sets how long to wait for the evaluated condition to be true. The default timeout is 500 milliseconds.
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.UI.DefaultWait`1.PollingInterval">
      <summary>
            Gets or sets how often the condition should be evaluated. The default timeout is 500 milliseconds.
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.UI.DefaultWait`1.Message">
      <summary>
            Gets or sets the message to be displayed when time expires.
            </summary>
    </member>
    <member name="T:OpenQA.Selenium.Support.UI.ExpectedConditions">
      <summary>
            Supplies a set of common conditions that can be waited for using <see cref="T:OpenQA.Selenium.Support.UI.WebDriverWait" />.
            </summary>
      <example>
        <code>
            IWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(3))
            IWebElement element = wait.Until(ExpectedConditions.ElementExists(By.Id("foo")));
            </code>
      </example>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.ExpectedConditions.#ctor">
      <summary>
            Prevents a default instance of the <see cref="T:OpenQA.Selenium.Support.UI.ExpectedConditions" /> class from being created.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.ExpectedConditions.TitleIs(System.String)">
      <summary>
            An expectation for checking the title of a page.
            </summary>
      <param name="title">The expected title, which must be an exact match.</param>
      <returns>
        <see langword="true" /> when the title matches; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.ExpectedConditions.TitleContains(System.String)">
      <summary>
            An expectation for checking that the title of a page contains a case-sensitive substring.
            </summary>
      <param name="title">The fragment of title expected.</param>
      <returns>
        <see langword="true" /> when the title matches; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.ExpectedConditions.ElementExists(OpenQA.Selenium.By)">
      <summary>
            An expectation for checking that an element is present on the DOM of a
            page. This does not necessarily mean that the element is visible.
            </summary>
      <param name="locator">The locator used to find the element.</param>
      <returns>The <see cref="T:OpenQA.Selenium.IWebElement" /> once it is located.</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.ExpectedConditions.ElementIsVisible(OpenQA.Selenium.By)">
      <summary>
            An expectation for checking that an element is present on the DOM of a page
            and visible. Visibility means that the element is not only displayed but
            also has a height and width that is greater than 0.
            </summary>
      <param name="locator">The locator used to find the element.</param>
      <returns>The <see cref="T:OpenQA.Selenium.IWebElement" /> once it is located and visible.</returns>
    </member>
    <member name="T:OpenQA.Selenium.Support.UI.IClock">
      <summary>
            An interface describing time handling functions for timeouts.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.IClock.LaterBy(System.TimeSpan)">
      <summary>
            Gets the <see cref="T:System.DateTime" /> at a specified offset in the future.
            </summary>
      <param name="delay">The offset to use.</param>
      <returns>The <see cref="T:System.DateTime" /> at the specified offset in the future.</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.IClock.IsNowBefore(System.DateTime)">
      <summary>
            Gets a value indicating whether the current date and time is before the specified date and time.
            </summary>
      <param name="otherDateTime">The date and time values to compare the current date and time values to.</param>
      <returns>
        <see langword="true" /> if the current date and time is before the specified date and time; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="P:OpenQA.Selenium.Support.UI.IClock.Now">
      <summary>
            Gets the current date and time values.
            </summary>
    </member>
    <member name="T:OpenQA.Selenium.Support.UI.ILoadableComponent">
      <summary>
            Interface allows for the component to be used in Nested Component scenarios such that the
            child component class does not have to declare the generic type of the parent explicitly. 
            </summary>
      <example>
            public class HypotheticalLoadableComponent : LoadableComponent&lt;T&gt; {
              ILoadableComponent parent;
              public HypotheticalLoadableComponent(ILoadableComponent parent) {
                this.parent = parent;
              }
              protected void EvaluateLoadedStatus() { //code to determine loaded state }
              protected void ExecuteLoad() { 
                parent.Load();  //loads the parent
                //code to load this component
              }
            }
            </example>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.ILoadableComponent.Load">
      <summary>
            Loads the component.
            </summary>
      <returns>A reference to this <see cref="T:OpenQA.Selenium.Support.UI.ILoadableComponent" />.</returns>
    </member>
    <member name="T:OpenQA.Selenium.Support.UI.LoadableComponent`1">
      <summary>
            Represents any abstraction of something that can be loaded. This may be an entire web page, or
            simply a component within that page (such as a login box or menu) or even a service. 
            </summary>
      <typeparam name="T">The type to be returned (normally the subclass' type)</typeparam>
      <example>
            The expected usage is:
            <para><code>
            new HypotheticalComponent().Load();
            </code></para></example>
      <remarks>
            After the <see cref="M:OpenQA.Selenium.Support.UI.LoadableComponent`1.Load" /> method is called, the component will be loaded and
            ready for use. Overload the protected Load and IsLoaded members to both load a component and determine
            if the component is already loaded.
            </remarks>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.LoadableComponent`1.Load">
      <summary>
            Ensure that the component is currently loaded.
            </summary>
      <returns>The loaded component.</returns>
      <remarks>This is equivalent to the Get() method in Java version.</remarks>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.LoadableComponent`1.HandleLoadError(OpenQA.Selenium.WebDriverException)">
      <summary>
            HandleLoadError gives a subclass the opportunity to handle a <see cref="T:OpenQA.Selenium.WebDriverException" /> that occurred
            during the execution of <see cref="M:OpenQA.Selenium.Support.UI.LoadableComponent`1.ExecuteLoad" />.
            </summary>
      <param name="ex">The exception which occurs on load.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.LoadableComponent`1.ExecuteLoad">
      <summary>
            When this method returns, the component modeled by the subclass should be fully loaded. This
            subclass is expected to navigate to an appropriate page or trigger loading the correct HTML
            should this be necessary.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.LoadableComponent`1.EvaluateLoadedStatus">
      <summary>
            Determine whether or not the component is loaded. Subclasses are expected to provide the details
            to determine if the page or component is loaded.
            </summary>
      <returns>A boolean value indicating if the component is loaded.</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.LoadableComponent`1.TryLoad">
      <summary>
            Attempts to load this component, providing an opportunity for the user to handle any errors encountered
            during the load process.
            </summary>
      <returns>A self-reference to this <see cref="T:OpenQA.Selenium.Support.UI.LoadableComponent`1" /></returns>
    </member>
    <member name="P:OpenQA.Selenium.Support.UI.LoadableComponent`1.UnableToLoadMessage">
      <summary>
            Gets or sets the message for the exception thrown when a component cannot be loaded
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.UI.LoadableComponent`1.IsLoaded">
      <summary>
            Gets a value indicating whether the component is fully loaded.
            </summary>
      <remarks>
            When the component is loaded, this property will return true or false depending on 
            the execution of <see cref="M:OpenQA.Selenium.Support.UI.LoadableComponent`1.EvaluateLoadedStatus" /> to indicate the not loaded state. 
            </remarks>
    </member>
    <member name="T:OpenQA.Selenium.Support.UI.LoadableComponentException">
      <summary>
            This exception is thrown by <see cref="T:OpenQA.Selenium.Support.UI.LoadableComponent`1" /> to indicate that
            the component was not successfully loaded.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.LoadableComponentException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.UI.LoadableComponentException" /> class.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.LoadableComponentException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.UI.LoadableComponentException" /> class with 
            a specified error message.
            </summary>
      <param name="message">The message of the exception</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.LoadableComponentException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.UI.LoadableComponentException" /> class with
            a specified error message and a reference to the inner exception that is the
            cause of this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception,
            or <see langword="null" /> if no inner exception is specified.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.LoadableComponentException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.UI.LoadableComponentException" /> class with serialized data.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized 
            object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual 
            information about the source or destination.</param>
    </member>
    <member name="T:OpenQA.Selenium.Support.UI.PopupWindowFinder">
      <summary>
            Provides a mechanism by which the window handle of an invoked
            popup browser window may be determined.
            </summary>
      <example>
        <code>
            // Store the current window handle so you can switch back to the
            // original window when you close the popup.
            string current = driver.CurrentWindowHandle;
            PopupWindowFinder finder = new PopupWindowFinder(driver);
            string newHandle = finder.Click(driver.FindElement(By.LinkText("Open new window")));
            driver.SwitchTo.Window(newHandle);
            </code>
      </example>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.PopupWindowFinder.#ctor(OpenQA.Selenium.IWebDriver)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.UI.PopupWindowFinder" /> class.
            </summary>
      <param name="driver">The <see cref="T:OpenQA.Selenium.IWebDriver" /> instance that is used
            to manipulate the popup window.</param>
      <remarks>When using this constructor overload, the timeout will be 5 seconds,
            and the check for a new window will be performed every 250 milliseconds.</remarks>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.PopupWindowFinder.#ctor(OpenQA.Selenium.IWebDriver,System.TimeSpan)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.UI.PopupWindowFinder" /> class
            with the specified timeout.
            </summary>
      <param name="driver">The <see cref="T:OpenQA.Selenium.IWebDriver" /> instance that is used
            to manipulate the popup window.</param>
      <param name="timeout">The <see cref="T:System.TimeSpan" /> representing the amount of
            time to wait for the popup window to appear.</param>
      <remarks>When using this constructor overload, the check for a new window
            will be performed every 250 milliseconds.</remarks>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.PopupWindowFinder.#ctor(OpenQA.Selenium.IWebDriver,System.TimeSpan,System.TimeSpan)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.UI.PopupWindowFinder" /> class
            with the specified timeout and using the specified interval to check for
            the existence of the new window.
            </summary>
      <param name="driver">The <see cref="T:OpenQA.Selenium.IWebDriver" /> instance that is used
            to manipulate the popup window.</param>
      <param name="timeout">The <see cref="T:System.TimeSpan" /> representing the amount of
            time to wait for the popup window to appear.</param>
      <param name="sleepInterval">The <see cref="T:System.TimeSpan" /> representing the
            amount of time to wait between checks of the available window handles.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.PopupWindowFinder.Click(OpenQA.Selenium.IWebElement)">
      <summary>
            Clicks on an element that is expected to trigger a popup browser window.
            </summary>
      <param name="element">The <see cref="T:OpenQA.Selenium.IWebElement" /> that, when clicked, invokes
            the popup browser window.</param>
      <returns>The window handle of the popup browser window.</returns>
      <exception cref="T:OpenQA.Selenium.WebDriverTimeoutException">Thrown if no popup window appears within the specified timeout.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if the element to click is <see langword="null" />.</exception>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.PopupWindowFinder.Invoke(System.Action)">
      <summary>
            Invokes a method that is expected to trigger a popup browser window.
            </summary>
      <param name="popupMethod">An <see cref="T:System.Action" /> that, when run, invokes
            the popup browser window.</param>
      <returns>The window handle of the popup browser window.</returns>
      <exception cref="T:OpenQA.Selenium.WebDriverTimeoutException">Thrown if no popup window appears within the specified timeout.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if the action to invoke is <see langword="null" />.</exception>
    </member>
    <member name="T:OpenQA.Selenium.Support.UI.SelectElement">
      <summary>
            Provides a convenience method for manipulating selections of options in an HTML select element.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.SelectElement.#ctor(OpenQA.Selenium.IWebElement)">
      <summary>
            Initializes a new instance of the SelectElement class.
            </summary>
      <param name="element">The element to be wrapped</param>
      <exception cref="T:System.ArgumentNullException">Thrown when the <see cref="T:OpenQA.Selenium.IWebElement" /> object is <see langword="null" /></exception>
      <exception cref="T:OpenQA.Selenium.Support.UI.UnexpectedTagNameException">Thrown when the element wrapped is not a &lt;select&gt; element.</exception>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.SelectElement.SelectByText(System.String)">
      <summary>
            Select all options by the text displayed.
            </summary>
      <param name="text">The text of the option to be selected. If an exact match is not found,
            this method will perform a substring match.</param>
      <remarks>When given "Bar" this method would select an option like:
            <para>
            &lt;option value="foo"&gt;Bar&lt;/option&gt;
            </para></remarks>
      <exception cref="T:OpenQA.Selenium.NoSuchElementException">Thrown if there is no element with the given text present.</exception>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.SelectElement.SelectByValue(System.String)">
      <summary>
            Select an option by the value.
            </summary>
      <param name="value">The value of the option to be selected.</param>
      <remarks>When given "foo" this method will select an option like:
            <para>
            &lt;option value="foo"&gt;Bar&lt;/option&gt;
            </para></remarks>
      <exception cref="T:OpenQA.Selenium.NoSuchElementException">Thrown when no element with the specified value is found.</exception>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.SelectElement.SelectByIndex(System.Int32)">
      <summary>
            Select the option by the index, as determined by the "index" attribute of the element.
            </summary>
      <param name="index">The value of the index attribute of the option to be selected.</param>
      <exception cref="T:OpenQA.Selenium.NoSuchElementException">Thrown when no element exists with the specified index attribute.</exception>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.SelectElement.DeselectAll">
      <summary>
            Clear all selected entries. This is only valid when the SELECT supports multiple selections.
            </summary>
      <exception cref="T:OpenQA.Selenium.WebDriverException">Thrown when attempting to deselect all options from a SELECT 
            that does not support multiple selections.</exception>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.SelectElement.DeselectByText(System.String)">
      <summary>
            Deselect the option by the text displayed.
            </summary>
      <param name="text">The text of the option to be deselected.</param>
      <remarks>When given "Bar" this method would deselect an option like:
            <para>
            &lt;option value="foo"&gt;Bar&lt;/option&gt;
            </para></remarks>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.SelectElement.DeselectByValue(System.String)">
      <summary>
            Deselect the option having value matching the specified text.
            </summary>
      <param name="value">The value of the option to deselect.</param>
      <remarks>When given "foo" this method will deselect an option like:
            <para>
            &lt;option value="foo"&gt;Bar&lt;/option&gt;
            </para></remarks>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.SelectElement.DeselectByIndex(System.Int32)">
      <summary>
            Deselect the option by the index, as determined by the "index" attribute of the element.
            </summary>
      <param name="index">The value of the index attribute of the option to deselect.</param>
    </member>
    <member name="P:OpenQA.Selenium.Support.UI.SelectElement.IsMultiple">
      <summary>
            Gets a value indicating whether the parent element supports multiple selections.
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.UI.SelectElement.Options">
      <summary>
            Gets the list of options for the select element.
            </summary>
    </member>
    <member name="P:OpenQA.Selenium.Support.UI.SelectElement.SelectedOption">
      <summary>
            Gets the selected item within the select element.
            </summary>
      <remarks>If more than one item is selected this will return the first item.</remarks>
      <exception cref="T:OpenQA.Selenium.NoSuchElementException">Thrown if no option is selected.</exception>
    </member>
    <member name="P:OpenQA.Selenium.Support.UI.SelectElement.AllSelectedOptions">
      <summary>
            Gets all of the selected options within the select element.
            </summary>
    </member>
    <member name="T:OpenQA.Selenium.Support.UI.SlowLoadableComponent`1">
      <summary>
            A <see cref="T:OpenQA.Selenium.Support.UI.LoadableComponent`1" /> which might not have finished loading when Load() returns. After a
            call to Load(), the IsLoaded property should continue to return false until the component has fully
            loaded. Use the HandleErrors() method to check for error conditions which caused the Load() to fail.
            <para><pre class="code">
            new SlowHypotheticalComponent().Load();
            </pre></para></summary>
      <typeparam name="T">The type to be returned (normally the subclass' type)</typeparam>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.SlowLoadableComponent`1.#ctor(System.TimeSpan)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.UI.SlowLoadableComponent`1" /> class.
            </summary>
      <param name="timeout">The <see cref="T:System.TimeSpan" /> within which the component should be loaded.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.SlowLoadableComponent`1.#ctor(System.TimeSpan,OpenQA.Selenium.Support.UI.IClock)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.UI.SlowLoadableComponent`1" /> class.
            </summary>
      <param name="timeout">The <see cref="T:System.TimeSpan" /> within which the component should be loaded.</param>
      <param name="clock">The <see cref="T:OpenQA.Selenium.Support.UI.IClock" /> to use when measuring the timeout.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.SlowLoadableComponent`1.Load">
      <summary>
            Ensures that the component is currently loaded.
            </summary>
      <returns>The loaded component.</returns>
      <remarks>This is equivalent to the Get() method in Java version.</remarks>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.SlowLoadableComponent`1.HandleErrors">
      <summary>
            Checks for well known error cases, which would mean that loading has finished, but an error
            condition was seen.
            </summary>
      <remarks>
            This method should be overridden so that expected errors can be automatically handled.
            </remarks>
    </member>
    <member name="P:OpenQA.Selenium.Support.UI.SlowLoadableComponent`1.SleepInterval">
      <summary>
            Gets or sets the time to sleep between each check of the load status of the component.
            </summary>
    </member>
    <member name="T:OpenQA.Selenium.Support.UI.SystemClock">
      <summary>
            Uses the system clock to calculate time for timeouts.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.SystemClock.LaterBy(System.TimeSpan)">
      <summary>
            Calculates the date and time values after a specific delay.
            </summary>
      <param name="delay">The delay after to calculate.</param>
      <returns>The future date and time values.</returns>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.SystemClock.IsNowBefore(System.DateTime)">
      <summary>
            Gets a value indicating whether the current date and time is before the specified date and time.
            </summary>
      <param name="otherDateTime">The date and time values to compare the current date and time values to.</param>
      <returns>
        <see langword="true" /> if the current date and time is before the specified date and time; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="P:OpenQA.Selenium.Support.UI.SystemClock.Now">
      <summary>
            Gets the current date and time values.
            </summary>
    </member>
    <member name="T:OpenQA.Selenium.Support.UI.UnexpectedTagNameException">
      <summary>
            The exception thrown when using the Select class on a tag that 
            does not support the HTML select element's selection semantics.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.UnexpectedTagNameException.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.UI.UnexpectedTagNameException" /> class with
            the expected tag name and the actual tag name.
            </summary>
      <param name="expected">The tag name that was expected.</param>
      <param name="actual">The actual tag name of the element.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.UnexpectedTagNameException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.UI.UnexpectedTagNameException" /> class.
            </summary>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.UnexpectedTagNameException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.UI.UnexpectedTagNameException" /> class with 
            a specified error message.
            </summary>
      <param name="message">The message of the exception</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.UnexpectedTagNameException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.UI.UnexpectedTagNameException" /> class with
            a specified error message and a reference to the inner exception that is the
            cause of this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception,
            or <see langword="null" /> if no inner exception is specified.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.UnexpectedTagNameException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.UI.UnexpectedTagNameException" /> class with serialized data.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized 
            object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual 
            information about the source or destination.</param>
    </member>
    <member name="T:OpenQA.Selenium.Support.UI.WebDriverWait">
      <summary>
            Provides the ability to wait for an arbitrary condition during test execution.
            </summary>
      <example>
        <code>
            IWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(3))
            IWebElement element = wait.Until(driver =&gt; driver.FindElement(By.Name("q")));
            </code>
      </example>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.WebDriverWait.#ctor(OpenQA.Selenium.IWebDriver,System.TimeSpan)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.UI.WebDriverWait" /> class.
            </summary>
      <param name="driver">The WebDriver instance used to wait.</param>
      <param name="timeout">The timeout value indicating how long to wait for the condition.</param>
    </member>
    <member name="M:OpenQA.Selenium.Support.UI.WebDriverWait.#ctor(OpenQA.Selenium.Support.UI.IClock,OpenQA.Selenium.IWebDriver,System.TimeSpan,System.TimeSpan)">
      <summary>
            Initializes a new instance of the <see cref="T:OpenQA.Selenium.Support.UI.WebDriverWait" /> class.
            </summary>
      <param name="clock">An object implementing the <see cref="T:OpenQA.Selenium.Support.UI.IClock" /> interface used to determine when time has passed.</param>
      <param name="driver">The WebDriver instance used to wait.</param>
      <param name="timeout">The timeout value indicating how long to wait for the condition.</param>
      <param name="sleepInterval">A <see cref="T:System.TimeSpan" /> value indicating how often to check for the condition to be true.</param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.ReferenceAttribute">
      <summary>
            Specifies assignment by reference rather than by copying.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IfExistsAttribute">
      <summary>
            Suppresses any on-demand behaviors.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryBehavior">
      <summary>
            Defines the contract for customizing dictionary access.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryBehavior.Copy">
      <summary>
            Copies the dictionary behavior.
            </summary>
      <returns>null if should not be copied.  Otherwise copy.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.IDictionaryBehavior.ExecutionOrder">
      <summary>
            Determines relative order to apply related behaviors.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.DictionaryBehaviorAttribute">
      <summary>
            Assigns a specific dictionary key.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryPropertySetter">
      <summary>
            Defines the contract for updating dictionary values.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryPropertySetter.SetPropertyValue(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,System.Object@,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Sets the stored dictionary value.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="value">The stored value.</param>
      <param name="property">The property.</param>
      <returns>true if the property should be stored.</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.RemoveIfAttribute">
      <summary>
            Removes a property if matches value.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.ICondition">
      <summary>
            Contract for value matching.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.RemoveIfEmptyAttribute">
      <summary>
            Removes a property if null or empty string, guid or collection.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.VolatileAttribute">
      <summary>
            Indicates that underlying values are changeable and should not be cached.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryInitializer">
      <summary>
             Contract for dictionary initialization.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryInitializer.Initialize(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.Object[])">
      <summary>
            Performs any initialization of the <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter" /></summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="behaviors">The dictionary behaviors.</param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryAdapterVisitor">
      <summary>
            Conract for traversing a <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter" />.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapterVisitor">
      <summary>
            Abstract implementation of <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapterVisitor" />.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryCreate">
      <summary>
            Contract for creating additional Dictionary adapters.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryEdit">
      <summary>
            Contract for editing the Dictionary adapter.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryNotify">
      <summary>
            Contract for managing Dictionary adapter notifications.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryValidate">
      <summary>
            Contract for validating Dictionary adapter.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter">
      <summary>
            Contract for manipulating the Dictionary adapter.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryBehaviorBuilder">
      <summary>
            Defines the contract for building <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryBehavior" />s.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryBehaviorBuilder.BuildBehaviors">
      <summary>
            Builds the dictionary behaviors.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter">
      <summary>
            Abstract adapter for the <see cref="T:System.Collections.IDictionary" /> support
            needed by the <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory" /></summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Add(System.Object,System.Object)">
      <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <param name="key">The <see cref="T:System.Object"></see> to use as the key of the element to add.</param>
      <param name="value">The <see cref="T:System.Object"></see> to use as the value of the element to add.</param>
      <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.IDictionary"></see> object. </exception>
      <exception cref="T:System.ArgumentNullException">key is null. </exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"></see> is read-only.-or- The <see cref="T:System.Collections.IDictionary"></see> has a fixed size. </exception>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Clear">
      <summary>
            Removes all elements from the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"></see> object is read-only. </exception>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Contains(System.Object)">
      <summary>
            Determines whether the <see cref="T:System.Collections.IDictionary"></see> object contains an element with the specified key.
            </summary>
      <param name="key">The key to locate in the <see cref="T:System.Collections.IDictionary"></see> object.</param>
      <returns>
            true if the <see cref="T:System.Collections.IDictionary"></see> contains an element with the key; otherwise, false.
            </returns>
      <exception cref="T:System.ArgumentNullException">key is null. </exception>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.GetEnumerator">
      <summary>
            Returns an <see cref="T:System.Collections.IDictionaryEnumerator"></see> object for the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IDictionaryEnumerator"></see> object for the <see cref="T:System.Collections.IDictionary"></see> object.
            </returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Remove(System.Object)">
      <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <param name="key">The key of the element to remove.</param>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"></see> object is read-only.-or- The <see cref="T:System.Collections.IDictionary"></see> has a fixed size. </exception>
      <exception cref="T:System.ArgumentNullException">key is null. </exception>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.CopyTo(System.Array,System.Int32)">
      <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"></see> to an <see cref="T:System.Array"></see>, starting at a particular <see cref="T:System.Array"></see> index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array"></see> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection"></see>. The <see cref="T:System.Array"></see> must have zero-based indexing.</param>
      <param name="index">The zero-based index in array at which copying begins.</param>
      <exception cref="T:System.ArgumentNullException">array is null. </exception>
      <exception cref="T:System.ArgumentException">The type of the source <see cref="T:System.Collections.ICollection"></see> cannot be cast automatically to the type of the destination array. </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">index is less than zero. </exception>
      <exception cref="T:System.ArgumentException">array is multidimensional.-or- index is equal to or greater than the length of array.-or- The number of elements in the source <see cref="T:System.Collections.ICollection"></see> is greater than the available space from index to the end of the destination array. </exception>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.IsFixedSize">
      <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary"></see> object has a fixed size.
            </summary>
      <value>
      </value>
      <returns>true if the <see cref="T:System.Collections.IDictionary"></see> object has a fixed size; otherwise, false.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.IsReadOnly">
      <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary"></see> object is read-only.
            </summary>
      <value>
      </value>
      <returns>true if the <see cref="T:System.Collections.IDictionary"></see> object is read-only; otherwise, false.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Keys">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection"></see> object containing the keys of the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <value>
      </value>
      <returns>An <see cref="T:System.Collections.ICollection"></see> object containing the keys of the <see cref="T:System.Collections.IDictionary"></see> object.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Values">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection"></see> object containing the values in the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
      <value>
      </value>
      <returns>An <see cref="T:System.Collections.ICollection"></see> object containing the values in the <see cref="T:System.Collections.IDictionary"></see> object.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Item(System.Object)">
      <summary>
            Gets or sets the <see cref="T:System.Object" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.Count">
      <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.ICollection"></see>.
            </summary>
      <value>
      </value>
      <returns>The number of elements contained in the <see cref="T:System.Collections.ICollection"></see>.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.IsSynchronized">
      <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"></see> is synchronized (thread safe).
            </summary>
      <value>
      </value>
      <returns>true if access to the <see cref="T:System.Collections.ICollection"></see> is synchronized (thread safe); otherwise, false.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter.SyncRoot">
      <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"></see>.
            </summary>
      <value>
      </value>
      <returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"></see>.</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.BindingList`1">
      <summary>
              Provides a generic collection that supports data binding.
            </summary>
      <remarks>
              This class wraps the CLR <see cref="T:System.ComponentModel.BindingList`1" />
              in order to implement the Castle-specific <see cref="T:Castle.Components.DictionaryAdapter.IBindingList`1" />.
            </remarks>
      <typeparam name="T">The type of elements in the list.</typeparam>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.BindingList`1.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.BindingList`1" /> class
              using default values.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.BindingList`1.#ctor(System.Collections.Generic.IList{`0})">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.BindingList`1" /> class
              with the specified list.
            </summary>
      <param name="list">
              An <see cref="T:System.Collections.Generic.IList`1" /> of items
              to be contained in the <see cref="T:Castle.Components.DictionaryAdapter.BindingList`1" />.
            </param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.BindingList`1.#ctor(System.ComponentModel.BindingList{`0})">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.BindingList`1" /> class
              wrapping the specified <see cref="T:System.ComponentModel.BindingList`1" /> instance.
            </summary>
      <param name="list">
              A <see cref="T:System.ComponentModel.BindingList`1" />
              to be wrapped by the <see cref="T:Castle.Components.DictionaryAdapter.BindingList`1" />.
            </param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter">
      <summary>
            Defines the contract for retrieving dictionary values.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter.GetPropertyValue(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,System.Object,Castle.Components.DictionaryAdapter.PropertyDescriptor,System.Boolean)">
      <summary>
            Gets the effective dictionary value.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="storedValue">The stored value.</param>
      <param name="property">The property.</param>
      <param name="ifExists">true if return only existing.</param>
      <returns>The effective property value.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.Xml.XmlAdapter.#ctor(Castle.Components.DictionaryAdapter.Xml.IXmlNode,Castle.Components.DictionaryAdapter.Xml.XmlReferenceManager)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.Xml.XmlAdapter" /> class
            that represents a child object in a larger object graph.
            </summary>
      <param name="node">
      </param>
      <param name="references">
      </param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer">
      <summary>
             Contract for dictionary meta-data initialization.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer.Initialize(Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory,Castle.Components.DictionaryAdapter.DictionaryAdapterMeta)">
      <summary>
            	Initializes the given <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> object.
            </summary>
      <param name="factory">The dictionary adapter factory.</param>
      <param name="dictionaryMeta">The dictionary adapter meta.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer.ShouldHaveBehavior(System.Object)">
      <summary>
            	Determines whether the given behavior should be included in a new
            	<see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> object.
            </summary>
      <param name="behavior">A dictionary behavior or annotation.</param>
      <returns>True if the behavior should be included; otherwise, false.</returns>
      <remarks>
        <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer" /> behaviors are always included,
            	regardless of the result of this method.
            </remarks>
    </member>
    <member name="M:Castle.Core.Internal.CollectionExtensions.IsNullOrEmpty(System.Collections.IEnumerable)">
      <summary>
              Checks whether or not collection is null or empty. Assumes colleciton can be safely enumerated multiple times.
            </summary>
      <param name="this">
      </param>
      <returns>
      </returns>
    </member>
    <member name="F:Castle.Core.Internal.InternalsVisible.ToCastleCore">
      <summary>
              Constant to use when making assembly internals visible to Castle.Core 
              <c>[assembly: InternalsVisibleTo(CoreInternalsVisible.ToCastleCore)]</c></summary>
    </member>
    <member name="F:Castle.Core.Internal.InternalsVisible.ToDynamicProxyGenAssembly2">
      <summary>
              Constant to use when making assembly internals visible to proxy types generated by DynamicProxy. Required when proxying internal types.
              <c>[assembly: InternalsVisibleTo(CoreInternalsVisible.ToDynamicProxyGenAssembly2)]</c></summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder">
      <summary>
            Defines the contract for building typed dictionary keys.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder.GetKey(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Builds the specified key.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The current key.</param>
      <param name="property">The property.</param>
      <returns>The updated key</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.ComponentAttribute">
      <summary>
            Identifies a property should be represented as a nested component.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.ComponentAttribute.NoPrefix">
      <summary>
            Applies no prefix.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.ComponentAttribute.Prefix">
      <summary>
            Gets or sets the prefix.
            </summary>
      <value>The prefix.</value>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.DictionaryAdapterAttribute">
      <summary>
            Identifies the dictionary adapter types.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.FetchAttribute">
      <summary>
            Identifies an interface or property to be pre-fetched.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.FetchAttribute.#ctor">
      <summary>
            Instructs fetching to occur.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.FetchAttribute.#ctor(System.Boolean)">
      <summary>
            Instructs fetching according to <paramref name="fetch" /></summary>
      <param name="fetch">
      </param>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.FetchAttribute.Fetch">
      <summary>
            Gets whether or not fetching should occur.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.GroupAttribute">
      <summary>
            Assigns a property to a group.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.GroupAttribute.#ctor(System.Object)">
      <summary>
            Constructs a group assignment.
            </summary>
      <param name="group">The group name.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.GroupAttribute.#ctor(System.Object[])">
      <summary>
            Constructs a group assignment.
            </summary>
      <param name="group">The group name.</param>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.GroupAttribute.Group">
      <summary>
            Gets the group the property is assigned to.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.KeyAttribute">
      <summary>
            Assigns a specific dictionary key.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.KeyAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.KeyAttribute" /> class.
            </summary>
      <param name="key">The key.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.KeyAttribute.#ctor(System.String[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.KeyAttribute" /> class.
            </summary>
      <param name="keys">The compound key.</param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.KeyPrefixAttribute">
      <summary>
            Assigns a prefix to the keyed properties of an interface.
            </summary>
      <remarks>
            Key prefixes are not inherited by sub-interfaces.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.KeyPrefixAttribute.#ctor">
      <summary>
            Initializes a default instance of the <see cref="T:Castle.Components.DictionaryAdapter.KeyPrefixAttribute" /> class.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.KeyPrefixAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.KeyPrefixAttribute" /> class.
            </summary>
      <param name="keyPrefix">The prefix for the keyed properties of the interface.</param>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.KeyPrefixAttribute.KeyPrefix">
      <summary>
            Gets the prefix key added to the properties of the interface.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.KeySubstitutionAttribute">
      <summary>
            Substitutes part of key with another string.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.KeySubstitutionAttribute.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.KeySubstitutionAttribute" /> class.
            </summary>
      <param name="oldValue">The old value.</param>
      <param name="newValue">The new value.</param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.MultiLevelEditAttribute">
      <summary>
            Requests support for multi-level editing.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.NewGuidAttribute">
      <summary>
            Generates a new GUID on demand.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.OnDemandAttribute">
      <summary>
            Support for on-demand value resolution.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.StringFormatAttribute">
      <summary>
            Provides simple string formatting from existing properties.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.StringFormatAttribute.Format">
      <summary>
            Gets the string format.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.StringFormatAttribute.Properties">
      <summary>
            Gets the format properties.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.StringListAttribute">
      <summary>
            Identifies a property should be represented as a delimited string value.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.StringListAttribute.Separator">
      <summary>
            Gets the separator.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.StringValuesAttribute">
      <summary>
            Converts all properties to strings.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.StringValuesAttribute.Format">
      <summary>
            Gets or sets the format.
            </summary>
      <value>The format.</value>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IPropertyDescriptorInitializer">
      <summary>
             Contract for property descriptor initialization.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IPropertyDescriptorInitializer.Initialize(Castle.Components.DictionaryAdapter.PropertyDescriptor,System.Object[])">
      <summary>
            Performs any initialization of the <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /></summary>
      <param name="propertyDescriptor">The property descriptor.</param>
      <param name="behaviors">The property behaviors.</param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.SuppressNotificationsAttribute">
      <summary>
            Suppress property change notifications.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.TypeKeyPrefixAttribute">
      <summary>
            Assigns a prefix to the keyed properties using the interface name.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.DefaultPropertyGetter">
      <summary>
            Manages conversion between property values.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DefaultPropertyGetter.#ctor(System.ComponentModel.TypeConverter)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.DefaultPropertyGetter" /> class.
            </summary>
      <param name="converter">The converter.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DefaultPropertyGetter.GetPropertyValue(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,System.Object,Castle.Components.DictionaryAdapter.PropertyDescriptor,System.Boolean)">
      <summary>
            Gets the effective dictionary value.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="storedValue">The stored value.</param>
      <param name="property">The property.</param>
      <param name="ifExists">true if return only existing.</param>
      <returns>The effective property value.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.DefaultPropertyGetter.ExecutionOrder">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory">
      <summary>
            Defines the contract for building typed dictionary adapters.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter``1(System.Collections.IDictionary)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Collections.IDictionary" />.
            </summary>
      <typeparam name="T">The typed interface.</typeparam>
      <param name="dictionary">The underlying source of properties.</param>
      <returns>An implementation of the typed interface bound to the dictionary.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter(System.Type,System.Collections.IDictionary)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Collections.IDictionary" />.
            </summary>
      <param name="type">The typed interface.</param>
      <param name="dictionary">The underlying source of properties.</param>
      <returns>An implementation of the typed interface bound to the dictionary.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter(System.Type,System.Collections.IDictionary,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Collections.IDictionary" />.
            </summary>
      <param name="type">The typed interface.</param>
      <param name="dictionary">The underlying source of properties.</param>
      <param name="descriptor">The property descriptor.</param>
      <returns>An implementation of the typed interface bound to the dictionary.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter``1(System.Collections.Specialized.NameValueCollection)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Collections.Specialized.NameValueCollection" />.
            </summary>
      <typeparam name="T">The typed interface.</typeparam>
      <param name="nameValues">The underlying source of properties.</param>
      <returns>An implementation of the typed interface bound to the namedValues.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter(System.Type,System.Collections.Specialized.NameValueCollection)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Collections.Specialized.NameValueCollection" />.
            </summary>
      <param name="type">The typed interface.</param>
      <param name="nameValues">The underlying source of properties.</param>
      <returns>An implementation of the typed interface bound to the namedValues.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter``1(System.Xml.XmlNode)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Xml.XmlNode" />.
            </summary>
      <typeparam name="T">The typed interface.</typeparam>
      <param name="xmlNode">The underlying source of properties.</param>
      <returns>An implementation of the typed interface bound to the <see cref="T:System.Xml.XmlNode" />.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapter(System.Type,System.Xml.XmlNode)">
      <summary>
            Gets a typed adapter bound to the <see cref="T:System.Xml.XmlNode" />.
            </summary>
      <param name="type">The typed interface.</param>
      <param name="xmlNode">The underlying source of properties.</param>
      <returns>An implementation of the typed interface bound to the <see cref="T:System.Xml.XmlNode" />.</returns>
      <remarks>
            The type represented by T must be an interface with properties.
            </remarks>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapterMeta(System.Type)">
      <summary>
            Gets the <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> associated with the type.
            </summary>
      <param name="type">The typed interface.</param>
      <returns>The adapter meta-data.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapterMeta(System.Type,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Gets the <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> associated with the type.
            </summary>
      <param name="type">The typed interface.</param>
      <param name="descriptor">The property descriptor.</param>
      <returns>The adapter meta-data.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory.GetAdapterMeta(System.Type,Castle.Components.DictionaryAdapter.DictionaryAdapterMeta)">
      <summary>
            Gets the <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> associated with the type.
            </summary>
      <param name="type">The typed interface.</param>
      <param name="other">Another <see cref="T:Castle.Components.DictionaryAdapter.DictionaryAdapterMeta" /> from which to copy behaviors.</param>
      <returns>The adapter meta-data.</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory">
      <summary>
            Uses Reflection.Emit to expose the properties of a dictionary
            through a dynamic implementation of a typed interface.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter``1(System.Collections.IDictionary)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter(System.Type,System.Collections.IDictionary)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter(System.Type,System.Collections.IDictionary,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter``2(System.Collections.Generic.IDictionary{System.String,``1})">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter``1(System.Type,System.Collections.Generic.IDictionary{System.String,``0})">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter``1(System.Collections.Specialized.NameValueCollection)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter(System.Type,System.Collections.Specialized.NameValueCollection)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter``1(System.Xml.XmlNode)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapter(System.Type,System.Xml.XmlNode)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapterMeta(System.Type)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapterMeta(System.Type,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <inheritdoc />
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.DictionaryAdapterFactory.GetAdapterMeta(System.Type,Castle.Components.DictionaryAdapter.DictionaryAdapterMeta)">
      <inheritdoc />
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDictionaryValidator">
      <summary>
            Contract for dictionary validation.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryValidator.IsValid(Castle.Components.DictionaryAdapter.IDictionaryAdapter)">
      <summary>
            Determines if <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter" /> is valid.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <returns>true if valid.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryValidator.Validate(Castle.Components.DictionaryAdapter.IDictionaryAdapter)">
      <summary>
            Validates the <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter" />.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <returns>The error summary information.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryValidator.Validate(Castle.Components.DictionaryAdapter.IDictionaryAdapter,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Validates the <see cref="T:Castle.Components.DictionaryAdapter.IDictionaryAdapter" /> for a property.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="property">The property to validate.</param>
      <returns>The property summary information.</returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.IDictionaryValidator.Invalidate(Castle.Components.DictionaryAdapter.IDictionaryAdapter)">
      <summary>
            Invalidates any results cached by the validator.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.NameValueCollectionAdapter">
      <summary>
      </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.NameValueCollectionAdapter.#ctor(System.Collections.Specialized.NameValueCollection)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.NameValueCollectionAdapter" /> class.
            </summary>
      <param name="nameValues">The name values.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.NameValueCollectionAdapter.Contains(System.Object)">
      <summary>
            Determines whether the <see cref="T:System.Collections.IDictionary"></see> object contains an element with the specified key.
            </summary>
      <param name="key">The key to locate in the <see cref="T:System.Collections.IDictionary"></see> object.</param>
      <returns>
            true if the <see cref="T:System.Collections.IDictionary"></see> contains an element with the key; otherwise, false.
            </returns>
      <exception cref="T:System.ArgumentNullException">key is null. </exception>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.NameValueCollectionAdapter.Adapt(System.Collections.Specialized.NameValueCollection)">
      <summary>
            Adapts the specified name values.
            </summary>
      <param name="nameValues">The name values.</param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.NameValueCollectionAdapter.IsReadOnly">
      <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary"></see> object is read-only.
            </summary>
      <value>
      </value>
      <returns>true if the <see cref="T:System.Collections.IDictionary"></see> object is read-only; otherwise, false.</returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.NameValueCollectionAdapter.Item(System.Object)">
      <summary>
            Gets or sets the <see cref="T:System.Object" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.PropertyDescriptor">
      <summary>
            Describes a dictionary property.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.#ctor">
      <summary>
            Initializes an empty <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /> class.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.#ctor(System.Reflection.PropertyInfo,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /> class.
            </summary>
      <param name="property">The property.</param>
      <param name="annotations">The annotations.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.#ctor(System.Object[])">
      <summary>
            Initializes a new instance <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /> class.
            </summary>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.#ctor(Castle.Components.DictionaryAdapter.PropertyDescriptor,System.Boolean)">
      <summary>
             Copies an existinginstance of the <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /> class.
            </summary>
      <param name="source">
      </param>
      <param name="copyBehaviors">
      </param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.GetKey(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Gets the key.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="descriptor">The descriptor.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.GetPropertyValue(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,System.Object,Castle.Components.DictionaryAdapter.PropertyDescriptor,System.Boolean)">
      <summary>
            Gets the property value.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="storedValue">The stored value.</param>
      <param name="descriptor">The descriptor.</param>
      <param name="ifExists">true if return only existing.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.SetPropertyValue(Castle.Components.DictionaryAdapter.IDictionaryAdapter,System.String,System.Object@,Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Sets the property value.
            </summary>
      <param name="dictionaryAdapter">The dictionary adapter.</param>
      <param name="key">The key.</param>
      <param name="value">The value.</param>
      <param name="descriptor">The descriptor.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.AddBehavior(Castle.Components.DictionaryAdapter.IDictionaryBehavior)">
      <summary>
            Adds a single behavior.
            </summary>
      <param name="behavior">The behavior.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.AddBehaviors(Castle.Components.DictionaryAdapter.IDictionaryBehavior[])">
      <summary>
            Adds the behaviors.
            </summary>
      <param name="behaviors">The behaviors.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.AddBehaviors(System.Collections.Generic.IEnumerable{Castle.Components.DictionaryAdapter.IDictionaryBehavior})">
      <summary>
            Adds the behaviors.
            </summary>
      <param name="behaviors">The behaviors.</param>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.CopyBehaviors(Castle.Components.DictionaryAdapter.PropertyDescriptor)">
      <summary>
            Copies the behaviors to the other <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /></summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Components.DictionaryAdapter.PropertyDescriptor.Copy">
      <summary>
            Copies the <see cref="T:Castle.Components.DictionaryAdapter.PropertyDescriptor" /></summary>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.ExecutionOrder">
      <summary>
      </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.PropertyName">
      <summary>
            Gets the property name.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.PropertyType">
      <summary>
            Gets the property type.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.IsDynamicProperty">
      <summary>
            Returns true if the property is dynamic.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.State">
      <summary>
            Gets additional state.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Fetch">
      <summary>
            Determines if property should be fetched.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.IfExists">
      <summary>
            Determines if property must exist first.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.SuppressNotifications">
      <summary>
            Determines if notifications should occur.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Annotations">
      <summary>
            Gets the property behaviors.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.TypeConverter">
      <summary>
            Gets the type converter.
            </summary>
      <value>The type converter.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.ExtendedProperties">
      <summary>
            Gets the extended properties.
            </summary>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Behaviors">
      <summary>
            Gets the setter.
            </summary>
      <value>The setter.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.KeyBuilders">
      <summary>
            Gets the key builders.
            </summary>
      <value>The key builders.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Setters">
      <summary>
            Gets the setter.
            </summary>
      <value>The setter.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Getters">
      <summary>
            Gets the getter.
            </summary>
      <value>The getter.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.Initializers">
      <summary>
            Gets the initializers.
            </summary>
      <value>The initializers.</value>
    </member>
    <member name="P:Castle.Components.DictionaryAdapter.PropertyDescriptor.MetaInitializers">
      <summary>
            Gets the meta-data initializers.
            </summary>
      <value>The meta-data initializers.</value>
    </member>
    <member name="T:Castle.Core.Internal.AttributesUtil">
      <summary>
              Helper class for retrieving attributes.
            </summary>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.GetAttribute``1(System.Reflection.ICustomAttributeProvider)">
      <summary>
              Gets the attribute.
            </summary>
      <param name="member">The member.</param>
      <returns>The member attribute.</returns>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.GetAttributes``1(System.Reflection.ICustomAttributeProvider)">
      <summary>
              Gets the attributes. Does not consider inherited attributes!
            </summary>
      <param name="member">The member.</param>
      <returns>The member attributes.</returns>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.GetTypeAttribute``1(System.Type)">
      <summary>
              Gets the type attribute.
            </summary>
      <param name="type">The type.</param>
      <returns>The type attribute.</returns>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.GetTypeAttributes``1(System.Type)">
      <summary>
              Gets the type attributes.
            </summary>
      <param name="type">The type.</param>
      <returns>The type attributes.</returns>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.GetTypeConverter(System.Reflection.MemberInfo)">
      <summary>
              Gets the type converter.
            </summary>
      <param name="member">The member.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Internal.AttributesUtil.HasAttribute``1(System.Reflection.ICustomAttributeProvider)">
      <summary>
              Gets the attribute.
            </summary>
      <param name="member">The member.</param>
      <returns>The member attribute.</returns>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDynamicValue">
      <summary>
            Contract for dynamic value resolution.
            </summary>
    </member>
    <member name="T:Castle.Components.DictionaryAdapter.IDynamicValue`1">
      <summary>
            Contract for typed dynamic value resolution.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:Castle.Core.Logging.LoggerLevel">
      <summary>
              Supporting Logger levels.
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Off">
      <summary>
              Logging will be off
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Fatal">
      <summary>
              Fatal logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Error">
      <summary>
              Error logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Warn">
      <summary>
              Warn logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Info">
      <summary>
              Info logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Debug">
      <summary>
              Debug logging level
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.IInvocation">
      <summary>
              Encapsulates an invocation of a proxied method.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IInvocation.GetArgumentValue(System.Int32)">
      <summary>
              Gets the value of the argument at the specified <paramref name="index" />.
            </summary>
      <param name="index">The index.</param>
      <returns>The value of the argument at the specified <paramref name="index" />.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.IInvocation.GetConcreteMethod">
      <summary>
              Returns the concrete instantiation of the <see cref="P:Castle.DynamicProxy.IInvocation.Method" /> on the proxy, with any generic
              parameters bound to real types.
            </summary>
      <returns>
              The concrete instantiation of the <see cref="P:Castle.DynamicProxy.IInvocation.Method" /> on the proxy, or the <see cref="P:Castle.DynamicProxy.IInvocation.Method" /> if
              not a generic method.
            </returns>
      <remarks>
              Can be slower than calling <see cref="P:Castle.DynamicProxy.IInvocation.Method" />.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.IInvocation.GetConcreteMethodInvocationTarget">
      <summary>
              Returns the concrete instantiation of <see cref="P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" />, with any
              generic parameters bound to real types.
              For interface proxies, this will point to the <see cref="T:System.Reflection.MethodInfo" /> on the target class.
            </summary>
      <returns>The concrete instantiation of <see cref="P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" />, or
              <see cref="P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" /> if not a generic method.</returns>
      <remarks>
              In debug builds this can be slower than calling <see cref="P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget" />.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.IInvocation.Proceed">
      <summary>
              Proceeds the call to the next interceptor in line, and ultimately to the target method.
            </summary>
      <remarks>
              Since interface proxies without a target don't have the target implementation to proceed to,
              it is important, that the last interceptor does not call this method, otherwise a
              <see cref="T:System.NotImplementedException" /> will be thrown.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.IInvocation.SetArgumentValue(System.Int32,System.Object)">
      <summary>
              Overrides the value of an argument at the given <paramref name="index" /> with the
              new <paramref name="value" /> provided.
            </summary>
      <remarks>
              This method accepts an <see cref="T:System.Object" />, however the value provided must be compatible
              with the type of the argument defined on the method, otherwise an exception will be thrown.
            </remarks>
      <param name="index">The index of the argument to override.</param>
      <param name="value">The new value for the argument.</param>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.Arguments">
      <summary>
              Gets the arguments that the <see cref="P:Castle.DynamicProxy.IInvocation.Method" /> has been invoked with.
            </summary>
      <value>The arguments the method was invoked with.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.GenericArguments">
      <summary>
              Gets the generic arguments of the method.
            </summary>
      <value>The generic arguments, or null if not a generic method.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.InvocationTarget">
      <summary>
              Gets the object on which the invocation is performed. This is different from proxy object
              because most of the time this will be the proxy target object.
            </summary>
      <seealso cref="T:Castle.DynamicProxy.IChangeProxyTarget" />
      <value>The invocation target.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.Method">
      <summary>
              Gets the <see cref="T:System.Reflection.MethodInfo" /> representing the method being invoked on the proxy.
            </summary>
      <value>The <see cref="T:System.Reflection.MethodInfo" /> representing the method being invoked.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.MethodInvocationTarget">
      <summary>
              For interface proxies, this will point to the <see cref="T:System.Reflection.MethodInfo" /> on the target class.
            </summary>
      <value>The method invocation target.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.Proxy">
      <summary>
              Gets the proxy object on which the intercepted method is invoked.
            </summary>
      <value>Proxy object on which the intercepted method is invoked.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.ReturnValue">
      <summary>
              Gets or sets the return value of the method.
            </summary>
      <value>The return value of the method.</value>
    </member>
    <member name="P:Castle.DynamicProxy.IInvocation.TargetType">
      <summary>
              Gets the type of the target object for the intercepted method.
            </summary>
      <value>The type of the target object.</value>
    </member>
    <member name="T:Castle.DynamicProxy.IProxyGenerationHook">
      <summary>
              Used during the target type inspection process. Implementors have a chance to customize the
              proxy generation process.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyGenerationHook.MethodsInspected">
      <summary>
              Invoked by the generation process to notify that the whole process has completed.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyGenerationHook.NonProxyableMemberNotification(System.Type,System.Reflection.MemberInfo)">
      <summary>
              Invoked by the generation process to notify that a member was not marked as virtual.
            </summary>
      <param name="type">The type which declares the non-virtual member.</param>
      <param name="memberInfo">The non-virtual member.</param>
      <remarks>
              This method gives an opportunity to inspect any non-proxyable member of a type that has 
              been requested to be proxied, and if appropriate - throw an exception to notify the caller.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyGenerationHook.ShouldInterceptMethod(System.Type,System.Reflection.MethodInfo)">
      <summary>
              Invoked by the generation process to determine if the specified method should be proxied.
            </summary>
      <param name="type">The type which declares the given method.</param>
      <param name="methodInfo">The method to inspect.</param>
      <returns>True if the given method should be proxied; false otherwise.</returns>
    </member>
    <member name="T:Castle.DynamicProxy.Contributors.ITypeContributor">
      <summary>
              Interface describing elements composing generated type
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Contributors.MembersCollector.AcceptMethod(System.Reflection.MethodInfo,System.Boolean,Castle.DynamicProxy.IProxyGenerationHook)">
      <summary>
              Performs some basic screening and invokes the <see cref="T:Castle.DynamicProxy.IProxyGenerationHook" />
              to select methods.
            </summary>
      <param name="method">
      </param>
      <param name="onlyVirtuals">
      </param>
      <param name="hook">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.DynamicProxy.IAttributeDisassembler">
      <summary>
              Provides functionality for disassembling instances of attributes to CustomAttributeBuilder form, during the process of emiting new types by Dynamic Proxy.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IAttributeDisassembler.Disassemble(System.Attribute)">
      <summary>
              Disassembles given attribute instance back to corresponding CustomAttributeBuilder.
            </summary>
      <param name="attribute">An instance of attribute to disassemble</param>
      <returns>
        <see cref="T:System.Reflection.Emit.CustomAttributeBuilder" /> corresponding 1 to 1 to given attribute instance, or null reference.</returns>
      <remarks>
              Implementers should return <see cref="T:System.Reflection.Emit.CustomAttributeBuilder" /> that corresponds to given attribute instance 1 to 1,
              that is after calling specified constructor with specified arguments, and setting specified properties and fields with values specified
              we should be able to get an attribute instance identical to the one passed in <paramref name="attribute" />. Implementer can return null
              if it wishes to opt out of replicating the attribute. Notice however, that for some cases, like attributes passed explicitly by the user
              it is illegal to return null, and doing so will result in exception.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.HandleError(System.Type,System.Exception)">
      <summary>
              Handles error during disassembly process
            </summary>
      <param name="attributeType">Type of the attribute being disassembled</param>
      <param name="exception">Exception thrown during the process</param>
      <returns>usually null, or (re)throws the exception</returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.InitializeConstructorArgs(System.Type,System.Attribute,System.Reflection.ParameterInfo[])">
      <summary>
              Here we try to match a constructor argument to its value.
              Since we can't get the values from the assembly, we use some heuristics to get it.
              a/ we first try to match all the properties on the attributes by name (case insensitive) to the argument
              b/ if we fail we try to match them by property type, with some smarts about convertions (i,e: can use Guid for string).
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.ReplaceIfBetterMatch(System.Reflection.ParameterInfo,System.Reflection.PropertyInfo,System.Reflection.PropertyInfo)">
      <summary>
              We have the following rules here.
              Try to find a matching type, failing that, if the parameter is string, get the first property (under the assumption that
              we can convert it.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.AttributeDisassembler.ConvertValue(System.Object,System.Type)">
      <summary>
              Attributes can only accept simple types, so we return null for null,
              if the value is passed as string we call to string (should help with converting), 
              otherwise, we use the value as is (enums, integer, etc).
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.TypeUtil.GetAllInterfaces(System.Type[])">
      <summary>
              Returns list of all unique interfaces implemented given types, including their base interfaces.
            </summary>
      <param name="types">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.DynamicProxy.Serialization.CacheMappingsAttribute">
      <summary>
              Applied to the assemblies saved by <see cref="T:Castle.DynamicProxy.ModuleScope" /> in order to persist the cache data included in the persisted assembly.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.BaseProxyGenerator">
      <summary>
              Base class that exposes the common functionalities
              to proxy generation.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.AddMappingNoCheck(System.Type,Castle.DynamicProxy.Contributors.ITypeContributor,System.Collections.Generic.IDictionary{System.Type,Castle.DynamicProxy.Contributors.ITypeContributor})">
      <summary>
              It is safe to add mapping (no mapping for the interface exists)
            </summary>
      <param name="implementer">
      </param>
      <param name="interface">
      </param>
      <param name="mapping">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.GenerateParameterlessConstructor(Castle.DynamicProxy.Generators.Emitters.ClassEmitter,System.Type,Castle.DynamicProxy.Generators.Emitters.SimpleAST.FieldReference)">
      <summary>
              Generates a parameters constructor that initializes the proxy
              state with <see cref="T:Castle.DynamicProxy.StandardInterceptor" /> just to make it non-null.
              <para>
                This constructor is important to allow proxies to be XML serializable
              </para></summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.InvocationTypeGenerator.GetBaseCtorArguments(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,System.Reflection.ConstructorInfo@)">
      <summary>
              Generates the constructor for the class that extends
              <see cref="T:Castle.DynamicProxy.AbstractInvocation" /></summary>
      <param name="targetFieldType">
      </param>
      <param name="proxyGenerationOptions">
      </param>
      <param name="baseConstructor">
      </param>
    </member>
    <member name="T:Castle.DynamicProxy.IProxyBuilder">
      <summary>
              Abstracts the implementation of proxy type construction.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateClassProxyType(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates a proxy type for given <paramref name="classToProxy" />, implementing <paramref name="additionalInterfacesToProxy" />, using <paramref name="options" /> provided.
            </summary>
      <param name="classToProxy">The class type to proxy.</param>
      <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
      <remarks>
              Implementers should return a proxy type for the specified class and interfaces.
              Additional interfaces should be only 'mark' interfaces, that is, they should work like interface proxy without target. (See <see cref="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)" /> method.)
            </remarks>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
      <seealso cref="T:Castle.DynamicProxy.Generators.ClassProxyGenerator" />
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithTarget(System.Type,System.Type[],System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates a proxy type that proxies calls to <paramref name="interfaceToProxy" /> members on <paramref name="targetType" />, implementing <paramref name="additionalInterfacesToProxy" />, using <paramref name="options" /> provided.
            </summary>
      <param name="interfaceToProxy">The interface type to proxy.</param>
      <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
      <param name="targetType">Type implementing <paramref name="interfaceToProxy" /> on which calls to the interface members should be intercepted.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
      <remarks>
              Implementers should return a proxy type for the specified interface that 'proceeds' executions to the specified target.
              Additional interfaces should be only 'mark' interfaces, that is, they should work like interface proxy without target. (See <see cref="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)" /> method.)
            </remarks>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
      <seealso cref="T:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetGenerator" />
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithTargetInterface(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates a proxy type for given <paramref name="interfaceToProxy" /> and <parmaref name="additionalInterfacesToProxy" /> that delegates all calls to the provided interceptors and allows interceptors to switch the actual target of invocation.
            </summary>
      <param name="interfaceToProxy">The interface type to proxy.</param>
      <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
      <remarks>
              Implementers should return a proxy type for the specified interface(s) that delegate all executions to the specified interceptors
              and uses an instance of the interface as their targets (i.e. <see cref="P:Castle.DynamicProxy.IInvocation.InvocationTarget" />), rather than a class. All <see cref="T:Castle.DynamicProxy.IInvocation" /> classes should then implement <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface,
              to allow interceptors to switch invocation target with instance of another type implementing called interface.
            </remarks>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
      <seealso cref="T:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetInterfaceGenerator" />
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates a proxy type for given <paramref name="interfaceToProxy" /> that delegates all calls to the provided interceptors.
            </summary>
      <param name="interfaceToProxy">The interface type to proxy.</param>
      <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
      <remarks>
              Implementers should return a proxy type for the specified interface and additional interfaces that delegate all executions to the specified interceptors.
            </remarks>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is not public.
              Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
              pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
      <seealso cref="T:Castle.DynamicProxy.Generators.InterfaceProxyWithoutTargetGenerator" />
    </member>
    <member name="P:Castle.DynamicProxy.IProxyBuilder.Logger">
      <summary>
              Gets or sets the <see cref="T:Castle.Core.Logging.ILogger" /> that this <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> logs to.
            </summary>
    </member>
    <member name="P:Castle.DynamicProxy.IProxyBuilder.ModuleScope">
      <summary>
              Gets the <see cref="P:Castle.DynamicProxy.IProxyBuilder.ModuleScope" /> associated with this builder.
            </summary>
      <value>The module scope associated with this builder.</value>
    </member>
    <member name="T:Castle.DynamicProxy.DefaultProxyBuilder">
      <summary>
              Default implementation of <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> interface producing in-memory proxy assemblies.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.DefaultProxyBuilder.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.DefaultProxyBuilder" /> class with new <see cref="P:Castle.DynamicProxy.DefaultProxyBuilder.ModuleScope" />.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.DefaultProxyBuilder.#ctor(Castle.DynamicProxy.ModuleScope)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.DefaultProxyBuilder" /> class.
            </summary>
      <param name="scope">The module scope for generated proxy types.</param>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.AttributeUtil.AddDisassembler``1(Castle.DynamicProxy.IAttributeDisassembler)">
      <summary>
              Registers custom disassembler to handle disassembly of specified type of attributes.
            </summary>
      <typeparam name="TAttribute">Type of attributes to handle</typeparam>
      <param name="disassembler">Disassembler converting existing instances of Attributes to CustomAttributeBuilders</param>
      <remarks>
              When disassembling an attribute Dynamic Proxy will first check if an custom disassembler has been registered to handle attributes of that type, 
              and if none is found, it'll use the <see cref="P:Castle.DynamicProxy.Internal.AttributeUtil.FallbackDisassembler" />.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.AttributeUtil.ShouldSkipAttributeReplication(System.Type)">
      <summary>
              Attributes should be replicated if they are non-inheritable,
              but there are some special cases where the attributes means
              something to the CLR, where they should be skipped.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.CacheKey.#ctor(System.Reflection.MemberInfo,System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.Generators.CacheKey" /> class.
            </summary>
      <param name="target">Target element. This is either target type or target method for invocation types.</param>
      <param name="type">The type of the proxy. This is base type for invocation types.</param>
      <param name="interfaces">The interfaces.</param>
      <param name="options">The options.</param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.CacheKey.#ctor(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.Generators.CacheKey" /> class.
            </summary>
      <param name="target">Type of the target.</param>
      <param name="interfaces">The interfaces.</param>
      <param name="options">The options.</param>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.LdcOpCodesDictionary">
      <summary>
              s
              Provides appropriate Ldc.X opcode for the type of primitive value to be loaded.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.LdindOpCodesDictionary">
      <summary>
              Provides appropriate Ldind.X opcode for 
              the type of primitive value to be loaded indirectly.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadIndirectOpCodeForType(System.Reflection.Emit.ILGenerator,System.Type)">
      <summary>
              Emits a load indirect opcode of the appropriate type for a value or object reference.
              Pops a pointer off the evaluation stack, dereferences it and loads
              a value of the specified type.
            </summary>
      <param name="gen">
      </param>
      <param name="type">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadOpCodeForConstantValue(System.Reflection.Emit.ILGenerator,System.Object)">
      <summary>
              Emits a load opcode of the appropriate kind for a constant string or
              primitive value.
            </summary>
      <param name="gen">
      </param>
      <param name="value">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadOpCodeForDefaultValueOfType(System.Reflection.Emit.ILGenerator,System.Type)">
      <summary>
              Emits a load opcode of the appropriate kind for the constant default value of a
              type, such as 0 for value types and null for reference types.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitStoreIndirectOpCodeForType(System.Reflection.Emit.ILGenerator,System.Type)">
      <summary>
              Emits a store indirectopcode of the appropriate type for a value or object reference.
              Pops a value of the specified type and a pointer off the evaluation stack, and
              stores the value.
            </summary>
      <param name="gen">
      </param>
      <param name="type">
      </param>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.PropertiesCollection">
      <summary>
              Summary description for PropertiesCollection.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.IndirectReference">
      <summary>
              Wraps a reference that is passed 
              ByRef and provides indirect load/store support.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.NewArrayExpression">
      <summary>
              Summary description for NewArrayExpression.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.ReferencesToObjectArrayExpression">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.StindOpCodesDictionary">
      <summary>
              Provides appropriate Stind.X opcode 
              for the type of primitive value to be stored indirectly.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.MetaEvent.#ctor(System.String,System.Type,System.Type,Castle.DynamicProxy.Generators.MetaMethod,Castle.DynamicProxy.Generators.MetaMethod,System.Reflection.EventAttributes)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.Generators.MetaEvent" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="declaringType">Type declaring the original event being overriten, or null.</param>
      <param name="eventDelegateType">
      </param>
      <param name="adder">The add method.</param>
      <param name="remover">The remove method.</param>
      <param name="attributes">The attributes.</param>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.INamingScope">
      <summary>
              Represents the scope of uniquenes of names for types and their members
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.INamingScope.GetUniqueName(System.String)">
      <summary>
              Gets a unique name based on <paramref name="suggestedName" /></summary>
      <param name="suggestedName">Name suggested by the caller</param>
      <returns>Unique name based on <paramref name="suggestedName" />.</returns>
      <remarks>
              Implementers should provide name as closely resembling <paramref name="suggestedName" /> as possible.
              Generally if no collision occurs it is suggested to return suggested name, otherwise append sequential suffix.
              Implementers must return deterministic names, that is when <see cref="M:Castle.DynamicProxy.Generators.INamingScope.GetUniqueName(System.String)" /> is called twice 
              with the same suggested name, the same returned name should be provided each time. Non-deterministic return
              values, like appending random suffices will break serialization of proxies.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.INamingScope.SafeSubScope">
      <summary>
              Returns new, disposable naming scope. It is responsibilty of the caller to make sure that no naming collision
              with enclosing scope, or other subscopes is possible.
            </summary>
      <returns>New naming scope.</returns>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.MethodFinder">
      <summary>
              Returns the methods implemented by a type. Use this instead of Type.GetMethods() to work around a CLR issue
              where duplicate MethodInfos are returned by Type.GetMethods() after a token of a generic type's method was loaded.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.InternalsUtil.IsInternal(System.Reflection.MethodBase)">
      <summary>
              Determines whether the specified method is internal.
            </summary>
      <param name="method">The method.</param>
      <returns>
        <c>true</c> if the specified method is internal; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.InternalsUtil.IsInternalToDynamicProxy(System.Reflection.Assembly)">
      <summary>
              Determines whether this assembly has internals visible to dynamic proxy.
            </summary>
      <param name="asm">The assembly to inspect.</param>
    </member>
    <member name="M:Castle.DynamicProxy.Internal.InternalsUtil.IsAccessible(System.Reflection.MethodBase)">
      <summary>
              Checks if the method is public or protected.
            </summary>
      <param name="method">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.MixinData.#ctor(System.Collections.Generic.IEnumerable{System.Object})">
      <summary>
              Because we need to cache the types based on the mixed in mixins, we do the following here:
              - Get all the mixin interfaces
              - Sort them by full name
              - Return them by position
            
            The idea is to have reproducible behavior for the case that mixins are registered in different orders.
            This method is here because it is required 
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.ModuleScope">
      <summary>
              Summary description for ModuleScope.
            </summary>
    </member>
    <member name="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME">
      <summary>
              The default file name used when the assembly is saved using <see cref="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME" />.
            </summary>
    </member>
    <member name="F:Castle.DynamicProxy.ModuleScope.DEFAULT_ASSEMBLY_NAME">
      <summary>
              The default assembly (simple) name used for the assemblies generated by a <see cref="T:Castle.DynamicProxy.ModuleScope" /> instance.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class; assemblies created by this instance will not be saved.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved.
            </summary>
      <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean,System.Boolean)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved.
            </summary>
      <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
      <param name="disableSignedModule">If set to <c>true</c> disables ability to generate signed module. This should be used in cases where ran under constrained permissions.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean,System.Boolean,System.String,System.String,System.String,System.String)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved and what simple names are to be assigned to them.
            </summary>
      <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
      <param name="disableSignedModule">If set to <c>true</c> disables ability to generate signed module. This should be used in cases where ran under constrained permissions.</param>
      <param name="strongAssemblyName">The simple name of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="strongModulePath">The path and file name of the manifest module of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="weakAssemblyName">The simple name of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="weakModulePath">The path and file name of the manifest module of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean,System.Boolean,Castle.DynamicProxy.Generators.INamingScope,System.String,System.String,System.String,System.String)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
              should be saved and what simple names are to be assigned to them.
            </summary>
      <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
      <param name="disableSignedModule">If set to <c>true</c> disables ability to generate signed module. This should be used in cases where ran under constrained permissions.</param>
      <param name="namingScope">Naming scope used to provide unique names to generated types and their members (usually via sub-scopes).</param>
      <param name="strongAssemblyName">The simple name of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="strongModulePath">The path and file name of the manifest module of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="weakAssemblyName">The simple name of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="weakModulePath">The path and file name of the manifest module of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.GetFromCache(Castle.DynamicProxy.Generators.CacheKey)">
      <summary>
              Returns a type from this scope's type cache, or null if the key cannot be found.
            </summary>
      <param name="key">The key to be looked up in the cache.</param>
      <returns>The type from this scope's type cache matching the key, or null if the key cannot be found</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.RegisterInCache(Castle.DynamicProxy.Generators.CacheKey,System.Type)">
      <summary>
              Registers a type in this scope's type cache.
            </summary>
      <param name="key">The key to be associated with the type.</param>
      <param name="type">The type to be stored in the cache.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.GetKeyPair">
      <summary>
              Gets the key pair used to sign the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModule(System.Boolean)">
      <summary>
              Gets the specified module generated by this scope, creating a new one if none has yet been generated.
            </summary>
      <param name="isStrongNamed">If set to true, a strong-named module is returned; otherwise, a weak-named module is returned.</param>
      <returns>A strong-named or weak-named module generated by this scope, as specified by the <paramref name="isStrongNamed" /> parameter.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModuleWithStrongName">
      <summary>
              Gets the strong-named module generated by this scope, creating a new one if none has yet been generated.
            </summary>
      <returns>A strong-named module generated by this scope.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModuleWithWeakName">
      <summary>
              Gets the weak-named module generated by this scope, creating a new one if none has yet been generated.
            </summary>
      <returns>A weak-named module generated by this scope.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.SaveAssembly">
      <summary>
              Saves the generated assembly with the name and directory information given when this <see cref="T:Castle.DynamicProxy.ModuleScope" /> instance was created (or with
              the <see cref="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME" /> and current directory if none was given).
            </summary>
      <remarks>
        <para>
                This method stores the generated assembly in the directory passed as part of the module information specified when this instance was
                constructed (if any, else the current directory is used). If both a strong-named and a weak-named assembly
                have been generated, it will throw an exception; in this case, use the <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly(System.Boolean)" /> overload.
              </para>
        <para>
                If this <see cref="T:Castle.DynamicProxy.ModuleScope" /> was created without indicating that the assembly should be saved, this method does nothing.
              </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">Both a strong-named and a weak-named assembly have been generated.</exception>
      <returns>The path of the generated assembly file, or null if no file has been generated.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.SaveAssembly(System.Boolean)">
      <summary>
              Saves the specified generated assembly with the name and directory information given when this <see cref="T:Castle.DynamicProxy.ModuleScope" /> instance was created
              (or with the <see cref="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME" /> and current directory if none was given).
            </summary>
      <param name="strongNamed">True if the generated assembly with a strong name should be saved (see <see cref="P:Castle.DynamicProxy.ModuleScope.StrongNamedModule" />);
              false if the generated assembly without a strong name should be saved (see <see cref="P:Castle.DynamicProxy.ModuleScope.WeakNamedModule" />.</param>
      <remarks>
        <para>
                This method stores the specified generated assembly in the directory passed as part of the module information specified when this instance was
                constructed (if any, else the current directory is used).
              </para>
        <para>
                If this <see cref="T:Castle.DynamicProxy.ModuleScope" /> was created without indicating that the assembly should be saved, this method does nothing.
              </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">No assembly has been generated that matches the <paramref name="strongNamed" /> parameter.
            </exception>
      <returns>The path of the generated assembly file, or null if no file has been generated.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.LoadAssemblyIntoCache(System.Reflection.Assembly)">
      <summary>
              Loads the generated types from the given assembly into this <see cref="T:Castle.DynamicProxy.ModuleScope" />'s cache.
            </summary>
      <param name="assembly">The assembly to load types from. This assembly must have been saved via <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly(System.Boolean)" /> or
              <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly" />, or it must have the <see cref="T:Castle.DynamicProxy.Serialization.CacheMappingsAttribute" /> manually applied.</param>
      <remarks>
              This method can be used to load previously generated and persisted proxy types from disk into this scope's type cache, eg. in order
              to avoid the performance hit associated with proxy generation.
            </remarks>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.Lock">
      <summary>
              Users of this <see cref="T:Castle.DynamicProxy.ModuleScope" /> should use this lock when accessing the cache.
            </summary>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModule">
      <summary>
              Gets the strong-named module generated by this scope, or <see langword="null" /> if none has yet been generated.
            </summary>
      <value>The strong-named module generated by this scope, or <see langword="null" /> if none has yet been generated.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModuleName">
      <summary>
              Gets the file name of the strongly named module generated by this scope.
            </summary>
      <value>The file name of the strongly named module generated by this scope.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModuleDirectory">
      <summary>
              Gets the directory where the strongly named module generated by this scope will be saved, or <see langword="null" /> if the current directory
              is used.
            </summary>
      <value>The directory where the strongly named module generated by this scope will be saved when <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly" /> is called
              (if this scope was created to save modules).</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModule">
      <summary>
              Gets the weak-named module generated by this scope, or <see langword="null" /> if none has yet been generated.
            </summary>
      <value>The weak-named module generated by this scope, or <see langword="null" /> if none has yet been generated.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModuleName">
      <summary>
              Gets the file name of the weakly named module generated by this scope.
            </summary>
      <value>The file name of the weakly named module generated by this scope.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModuleDirectory">
      <summary>
              Gets the directory where the weakly named module generated by this scope will be saved, or <see langword="null" /> if the current directory
              is used.
            </summary>
      <value>The directory where the weakly named module generated by this scope will be saved when <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly" /> is called
              (if this scope was created to save modules).</value>
    </member>
    <member name="T:Castle.DynamicProxy.PersistentProxyBuilder">
      <summary>
              ProxyBuilder that persists the generated type.
            </summary>
      <remarks>
              The saved assembly contains just the last generated type.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.PersistentProxyBuilder.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.PersistentProxyBuilder" /> class.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.PersistentProxyBuilder.SaveAssembly">
      <summary>
              Saves the generated assembly to a physical file. Note that this renders the <see cref="T:Castle.DynamicProxy.PersistentProxyBuilder" /> unusable.
            </summary>
      <returns>The path of the generated assembly file, or null if no assembly has been generated.</returns>
      <remarks>
              This method does not support saving multiple files. If both a signed and an unsigned module have been generated, use the 
              respective methods of the <see cref="T:Castle.DynamicProxy.ModuleScope" />.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerationOptions.#ctor(Castle.DynamicProxy.IProxyGenerationHook)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerationOptions" /> class.
            </summary>
      <param name="hook">The hook.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerationOptions.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerationOptions" /> class.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.ProxyGenerator">
      <summary>
              Provides proxy objects for classes and interfaces.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor(Castle.DynamicProxy.IProxyBuilder)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> class.
            </summary>
      <param name="builder">Proxy types builder.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> class.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor(System.Boolean)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> class.
            </summary>
      <param name="disableSignedModule">If <c>true</c> forces all types to be generated into an unsigned module.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget``1(``0,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TInterface">Type of the interface implemented by <paramref name="target" /> which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>Object proxying calls to members of <typeparamref name="TInterface" /> on <paramref name="target" /> object.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" />is not an interface type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TInterface">Type of the interface implemented by <paramref name="target" /> which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" />is not an interface type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types  on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method generates new proxy type for each type of <paramref name="target" />, which affects performance. If you don't want to proxy types differently depending on the type of the target
              use <see cref="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])" /> method.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <typeparam name="TInterface">Type of the interface implemented by <paramref name="target" /> which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> type on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" /> is not an interface type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <typeparam name="TInterface">Type of the interface implemented by <paramref name="target" /> which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> type on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" /> is not an interface type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
              Interceptors can use <see cref="T:Castle.DynamicProxy.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.DynamicProxy.IInterceptor)">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on target object generated at runtime with given <paramref name="interceptor" />.
            </summary>
      <typeparam name="TInterface">Type of the interface which will be proxied.</typeparam>
      <param name="interceptor">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptor" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              As a result of that also at least one <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementation must be provided.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TInterface">Type of the interface which will be proxied.</typeparam>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              As a result of that also at least one <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementation must be provided.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TInterface">Type of the interface which will be proxied.</typeparam>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <typeparamref name="TInterface" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              As a result of that also at least one <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementation must be provided.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.DynamicProxy.IInterceptor)">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptor" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="interceptor">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptor" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> type on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" />  is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
              Since this method uses an empty-shell implementation of <paramref name="additionalInterfacesToProxy" /> to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations.
              They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget``1(``0,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name="TClass" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TClass">Type of class which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <typeparamref name="TClass" /> proxying calls to virtual members of <typeparamref name="TClass" /> type.
            </returns>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TClass" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name="TClass" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name="TClass" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget``1(``0,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name="TClass" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TClass">Type of class which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <typeparamref name="TClass" /> proxying calls to virtual members of <typeparamref name="TClass" /> type.
            </returns>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TClass" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name="TClass" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name="TClass" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no parameterless constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy``1(Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name="TClass" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TClass">Type of class which will be proxied.</typeparam>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <typeparamref name="TClass" /> proxying calls to virtual members of <typeparamref name="TClass" /> type.
            </returns>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TClass" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name="TClass" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name="TClass" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy``1(Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <typeparamref name="TClass" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TClass">Type of class which will be proxied.</typeparam>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <typeparamref name="TClass" /> proxying calls to virtual members of <typeparamref name="TClass" /> type.
            </returns>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TClass" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <typeparamref name="TClass" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name="TClass" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no parameterless constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
              New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
              This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
              As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyType(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates the proxy type for class proxy with given <paramref name="classToProxy" /> class, implementing given <paramref name="additionalInterfacesToProxy" /> and using provided <paramref name="options" />.
            </summary>
      <param name="classToProxy">The base class for proxy type.</param>
      <param name="additionalInterfacesToProxy">The interfaces that proxy type should implement.</param>
      <param name="options">The options for proxy generation process.</param>
      <returns>
        <see cref="T:System.Type" /> of proxy.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithTarget(System.Type,System.Type[],System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates the proxy type for interface proxy with target for given <paramref name="interfaceToProxy" /> interface, implementing given <paramref name="additionalInterfacesToProxy" /> on given <paramref name="targetType" /> and using provided <paramref name="options" />.
            </summary>
      <param name="interfaceToProxy">The interface proxy type should implement.</param>
      <param name="additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
      <param name="targetType">Actual type that the proxy type will encompass.</param>
      <param name="options">The options for proxy generation process.</param>
      <returns>
        <see cref="T:System.Type" /> of proxy.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithTargetInterface(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates the proxy type for interface proxy with target interface for given <paramref name="interfaceToProxy" /> interface, implementing given <paramref name="additionalInterfacesToProxy" /> on given <paramref name="interfaceToProxy" /> and using provided <paramref name="options" />.
            </summary>
      <param name="interfaceToProxy">The interface proxy type should implement.</param>
      <param name="additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
      <param name="options">The options for proxy generation process.</param>
      <returns>
        <see cref="T:System.Type" /> of proxy.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
              Creates the proxy type for interface proxy without target for given <paramref name="interfaceToProxy" /> interface, implementing given <paramref name="additionalInterfacesToProxy" /> and using provided <paramref name="options" />.
            </summary>
      <param name="interfaceToProxy">The interface proxy type should implement.</param>
      <param name="additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
      <param name="options">The options for proxy generation process.</param>
      <returns>
        <see cref="T:System.Type" /> of proxy.</returns>
    </member>
    <member name="P:Castle.DynamicProxy.ProxyGenerator.Logger">
      <summary>
              Gets or sets the <see cref="T:Castle.Core.Logging.ILogger" /> that this <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> log to.
            </summary>
    </member>
    <member name="P:Castle.DynamicProxy.ProxyGenerator.ProxyBuilder">
      <summary>
              Gets the proxy builder instance used to generate proxy types.
            </summary>
      <value>The proxy builder.</value>
    </member>
    <member name="M:Castle.DynamicProxy.Serialization.RemotableInvocation.Proceed">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.DynamicProxy.Serialization.RemotableInvocation.Method">
      <summary>
      </summary>
    </member>
    <member name="P:Castle.DynamicProxy.Serialization.RemotableInvocation.MethodInvocationTarget">
      <summary>
              For interface proxies, this will point to the
              <see cref="T:System.Reflection.MethodInfo" /> on the target class
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Serialization.ProxyObjectReference">
      <summary>
              Handles the deserialization of proxies.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.ResetScope">
      <summary>
              Resets the <see cref="P:Castle.DynamicProxy.Serialization.ProxyObjectReference.ModuleScope" /> used for deserialization to a new scope.
            </summary>
      <remarks>
              This is useful for test cases.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.SetScope(Castle.DynamicProxy.ModuleScope)">
      <summary>
              Resets the <see cref="P:Castle.DynamicProxy.Serialization.ProxyObjectReference.ModuleScope" /> used for deserialization to a given <paramref name="scope" />.
            </summary>
      <param name="scope"> The scope to be used for deserialization. </param>
      <remarks>
              By default, the deserialization process uses a different scope than the rest of the application, which can lead to multiple proxies
              being generated for the same type. By explicitly setting the deserialization scope to the application's scope, this can be avoided.
            </remarks>
    </member>
    <member name="P:Castle.DynamicProxy.Serialization.ProxyObjectReference.ModuleScope">
      <summary>
              Gets the <see cref="P:Castle.DynamicProxy.Serialization.ProxyObjectReference.ModuleScope" /> used for deserialization.
            </summary>
      <value> As <see cref="T:Castle.DynamicProxy.Serialization.ProxyObjectReference" /> has no way of automatically determining the scope used by the application (and the application might use more than one scope at the same time), <see cref="T:Castle.DynamicProxy.Serialization.ProxyObjectReference" /> uses a dedicated scope instance for deserializing proxy types. This instance can be reset and set to a specific value via <see cref="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.ResetScope" /> and <see cref="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.SetScope(Castle.DynamicProxy.ModuleScope)" /> . </value>
    </member>
    <member name="T:Castle.DynamicProxy.Tokens.InvocationMethods">
      <summary>
              Holds <see cref="T:System.Reflection.MethodInfo" /> objects representing methods of <see cref="T:Castle.DynamicProxy.AbstractInvocation" /> class.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Tokens.SerializationInfoMethods">
      <summary>
              Holds <see cref="T:System.Reflection.MethodInfo" /> objects representing methods of <see cref="T:System.Runtime.Serialization.SerializationInfo" /> class.
            </summary>
    </member>
    <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.AddValue_Bool">
      <summary>
        <see cref="M:System.Runtime.Serialization.SerializationInfo.AddValue(System.String,System.Boolean)" />
      </summary>
    </member>
    <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.AddValue_Int32">
      <summary>
        <see cref="M:System.Runtime.Serialization.SerializationInfo.AddValue(System.String,System.Int32)" />
      </summary>
    </member>
    <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.AddValue_Object">
      <summary>
        <see cref="M:System.Runtime.Serialization.SerializationInfo.AddValue(System.String,System.Object)" />
      </summary>
    </member>
    <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.GetValue">
      <summary>
        <see cref="M:System.Runtime.Serialization.SerializationInfo.GetValue(System.String,System.Type)" />
      </summary>
    </member>
    <member name="F:Castle.DynamicProxy.Tokens.SerializationInfoMethods.SetType">
      <summary>
        <see cref="M:System.Runtime.Serialization.SerializationInfo.SetType(System.Type)" />
      </summary>
    </member>
    <member name="T:Castle.DynamicProxy.IInterceptorSelector">
      <summary>
              Provides an extension point that allows proxies to choose specific interceptors on
              a per method basis.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IInterceptorSelector.SelectInterceptors(System.Type,System.Reflection.MethodInfo,Castle.DynamicProxy.IInterceptor[])">
      <summary>
              Selects the interceptors that should intercept calls to the given <paramref name="method" />.
            </summary>
      <param name="type">The type declaring the method to intercept.</param>
      <param name="method">The method that will be intercepted.</param>
      <param name="interceptors">All interceptors registered with the proxy.</param>
      <returns>An array of interceptors to invoke upon calling the <paramref name="method" />.</returns>
      <remarks>
              This method is called only once per proxy instance, upon the first call to the
              <paramref name="method" />. Either an empty array or null are valid return values to indicate
              that no interceptor should intercept calls to the method. Although it is not advised, it is
              legal to return other <see cref="T:Castle.DynamicProxy.IInterceptor" /> implementations than these provided in
              <paramref name="interceptors" />.
            </remarks>
    </member>
    <member name="M:Castle.Core.Internal.Lock.Create">
      <summary>
            Creates a new lock.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.IServiceProviderExAccessor">
      <summary>
            This interface should be implemented by classes
            that are available in a bigger context, exposing
            the container to different areas in the same application.
            <para>
            For example, in Web application, the (global) HttpApplication
            subclasses should implement this interface to expose 
            the configured container
            </para></summary>
    </member>
    <member name="T:Castle.DynamicProxy.IChangeProxyTarget">
      <summary>
              Exposes means to change target objects of proxies and invocations
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IChangeProxyTarget.ChangeInvocationTarget(System.Object)">
      <summary>
              Changes the target object (<see cref="P:Castle.DynamicProxy.IInvocation.InvocationTarget" />) of current <see cref="T:Castle.DynamicProxy.IInvocation" />.
            </summary>
      <param name="target">The new value of target of invocation.</param>
      <remarks>
              Although the method takes <see cref="T:System.Object" /> the actual instance must be of type assignable to <see cref="P:Castle.DynamicProxy.IInvocation.TargetType" />, otherwise an <see cref="T:System.InvalidCastException" /> will be thrown.
              Also while it's technically legal to pass null reference (Nothing in Visual Basic) as <paramref name="target" />, for obvious reasons Dynamic Proxy will not be able to call the intercepted method on such target.
              In this case last interceptor in the pipeline mustn't call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see cref="T:System.NotImplementedException" /> will be throws.
              Also while it's technically legal to pass proxy itself as <paramref name="target" />, this would create stack overflow.
              In this case last interceptor in the pipeline mustn't call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see cref="T:System.InvalidOperationException" /> will be throws.
            </remarks>
      <exception cref="T:System.InvalidCastException">Thrown when <paramref name="target" /> is not assignable to the proxied type.</exception>
    </member>
    <member name="M:Castle.DynamicProxy.IChangeProxyTarget.ChangeProxyTarget(System.Object)">
      <summary>
              Permanently changes the target object of the proxy. This does not affect target of the current invocation.
            </summary>
      <param name="target">The new value of target of the proxy.</param>
      <remarks>
              Although the method takes <see cref="T:System.Object" /> the actual instance must be of type assignable to proxy's target type, otherwise an <see cref="T:System.InvalidCastException" /> will be thrown.
              Also while it's technically legal to pass null reference (Nothing in Visual Basic) as <paramref name="target" />, for obvious reasons Dynamic Proxy will not be able to call the intercepted method on such target.
              In this case last interceptor in the pipeline mustn't call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see cref="T:System.NotImplementedException" /> will be throws.
              Also while it's technically legal to pass proxy itself as <paramref name="target" />, this would create stack overflow.
              In this case last interceptor in the pipeline mustn't call <see cref="M:Castle.DynamicProxy.IInvocation.Proceed" /> or a <see cref="T:System.InvalidOperationException" /> will be throws.
            </remarks>
      <exception cref="T:System.InvalidCastException">Thrown when <paramref name="target" /> is not assignable to the proxied type.</exception>
    </member>
    <member name="T:Castle.DynamicProxy.IInterceptor">
      <summary>
              New interface that is going to be used by DynamicProxy 2
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyTargetAccessor.DynProxyGetTarget">
      <summary>
              Get the proxy target (note that null is a valid target!)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyTargetAccessor.GetInterceptors">
      <summary>
              Gets the interceptors for the proxy
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.IServiceEnabledComponent">
      <summary>
            Defines that the implementation wants a 
            <see cref="T:System.IServiceProvider" /> in order to 
            access other components. The creator must be aware
            that the component might (or might not) implement 
            the interface.
            </summary>
      <remarks>
            Used by Castle Project components to, for example, 
            gather logging factories
            </remarks>
    </member>
    <member name="T:Castle.Core.IServiceProviderEx">
      <summary>
            Increments <c>IServiceProvider</c> with a generic service resolution operation.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.ILoggerFactory">
      <summary>
              Manages the instantiation of <see cref="T:Castle.Core.Logging.ILogger" />s.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.Type)">
      <summary>
              Creates a new logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.String)">
      <summary>
              Creates a new logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new logger.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.IExtendedLoggerFactory">
      <summary>
              Provides a factory that can produce either <see cref="T:Castle.Core.Logging.ILogger" /> or
              <see cref="T:Castle.Core.Logging.IExtendedLogger" /> classes.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.Type)">
      <summary>
              Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.String)">
      <summary>
              Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Create(System.Type)">
      <summary>
              Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Create(System.String)">
      <summary>
              Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.AbstractExtendedLoggerFactory.GetConfigFile(System.String)">
      <summary>
              Gets the configuration file.
            </summary>
      <param name="fileName">i.e. log4net.config</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Logging.AbstractLoggerFactory.GetConfigFile(System.String)">
      <summary>
              Gets the configuration file.
            </summary>
      <param name="fileName">i.e. log4net.config</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Logging.TraceLoggerFactory">
      <summary>
              Used to create the TraceLogger implementation of ILogger interface. See <see cref="T:Castle.Core.Logging.TraceLogger" />.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.IContextProperties">
      <summary>
              Interface for Context Properties implementations
            </summary>
      <remarks>
        <para>
                This interface defines a basic property get set accessor.
              </para>
        <para>
                Based on the ContextPropertiesBase of log4net, by Nicko Cadell.
              </para>
      </remarks>
    </member>
    <member name="P:Castle.Core.Logging.IContextProperties.Item(System.String)">
      <summary>
              Gets or sets the value of a property
            </summary>
      <value>
              The value for the property with the specified key
            </value>
      <remarks>
        <para>
                Gets or sets the value of a property
              </para>
      </remarks>
    </member>
    <member name="T:Castle.Core.Logging.NullLogFactory">
      <summary>
            NullLogFactory used when logging is turned off.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.NullLogFactory.Create(System.String)">
      <summary>
              Creates an instance of ILogger with the specified name.
            </summary>
      <param name="name">Name.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Logging.NullLogFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates an instance of ILogger with the specified name and LoggerLevel.
            </summary>
      <param name="name">Name.</param>
      <param name="level">Level.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Logging.StreamLoggerFactory">
      <summary>
              Creates <see cref="T:Castle.Core.Logging.StreamLogger" /> outputing 
              to files. The name of the file is derived from the log name
              plus the 'log' extension.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.ILogger">
      <summary>
              Manages logging.
            </summary>
      <remarks>
              This is a facade for the different logging subsystems.
              It offers a simplified interface that follows IOC patterns
              and a simplified priority/level/severity abstraction.
            </remarks>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.CreateChildLogger(System.String)">
      <summary>
              Create a new child logger.
              The name of the child logger is [current-loggers-name].[passed-in-name]
            </summary>
      <param name="loggerName">The Subname of this logger.</param>
      <returns>The New ILogger instance.</returns>
      <exception cref="T:System.ArgumentException">If the name has an empty element name.</exception>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Debug(System.String)">
      <summary>
              Logs a debug message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Debug(System.Func{System.String})">
      <summary>
              Logs a debug message with lazily constructed message. The message will be constructed only if the <see cref="P:Castle.Core.Logging.ILogger.IsDebugEnabled" /> is true.
            </summary>
      <param name="messageFactory">
      </param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Debug(System.String,System.Exception)">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Error(System.String)">
      <summary>
              Logs an error message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Error(System.Func{System.String})">
      <summary>
              Logs an error message with lazily constructed message. The message will be constructed only if the <see cref="P:Castle.Core.Logging.ILogger.IsErrorEnabled" /> is true.
            </summary>
      <param name="messageFactory">
      </param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Error(System.String,System.Exception)">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String)">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Fatal(System.Func{System.String})">
      <summary>
              Logs a fatal message with lazily constructed message. The message will be constructed only if the <see cref="P:Castle.Core.Logging.ILogger.IsFatalEnabled" /> is true.
            </summary>
      <param name="messageFactory">
      </param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String,System.Exception)">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Info(System.String)">
      <summary>
              Logs an info message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Info(System.Func{System.String})">
      <summary>
              Logs a info message with lazily constructed message. The message will be constructed only if the <see cref="P:Castle.Core.Logging.ILogger.IsInfoEnabled" /> is true.
            </summary>
      <param name="messageFactory">
      </param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Info(System.String,System.Exception)">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Warn(System.String)">
      <summary>
              Logs a warn message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Warn(System.Func{System.String})">
      <summary>
              Logs a warn message with lazily constructed message. The message will be constructed only if the <see cref="P:Castle.Core.Logging.ILogger.IsWarnEnabled" /> is true.
            </summary>
      <param name="messageFactory">
      </param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Warn(System.String,System.Exception)">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsDebugEnabled">
      <summary>
              Determines if messages of priority "debug" will be logged.
            </summary>
      <value>True if "debug" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsErrorEnabled">
      <summary>
              Determines if messages of priority "error" will be logged.
            </summary>
      <value>True if "error" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsFatalEnabled">
      <summary>
              Determines if messages of priority "fatal" will be logged.
            </summary>
      <value>True if "fatal" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsInfoEnabled">
      <summary>
              Determines if messages of priority "info" will be logged.
            </summary>
      <value>True if "info" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsWarnEnabled">
      <summary>
              Determines if messages of priority "warn" will be logged.
            </summary>
      <value>True if "warn" messages will be logged.</value>
    </member>
    <member name="T:Castle.Core.Logging.IExtendedLogger">
      <summary>
              Provides an interface that supports <see cref="T:Castle.Core.Logging.ILogger" /> and
              allows the storage and retrieval of Contexts. These are supported in
              both log4net and NLog.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.IExtendedLogger.GlobalProperties">
      <summary>
              Exposes the Global Context of the extended logger.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.IExtendedLogger.ThreadProperties">
      <summary>
              Exposes the Thread Context of the extended logger.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.IExtendedLogger.ThreadStacks">
      <summary>
              Exposes the Thread Stack of the extended logger.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.LevelFilteredLogger">
      <summary>
            The Level Filtered Logger class.  This is a base clase which
            provides a LogLevel attribute and reroutes all functions into
            one Log method.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.#ctor">
      <summary>
              Creates a new <c>LevelFilteredLogger</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InitializeLifetimeService">
      <summary>
            Keep the instance alive in a remoting scenario
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Debug(System.String)">
      <summary>
              Logs a debug message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Debug(System.String,System.Exception)">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Info(System.String)">
      <summary>
              Logs an info message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Info(System.String,System.Exception)">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Warn(System.String)">
      <summary>
              Logs a warn message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Warn(System.String,System.Exception)">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Error(System.String)">
      <summary>
              Logs an error message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Error(System.String,System.Exception)">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Fatal(System.String)">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Fatal(System.String,System.Exception)">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.Exception,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Log(Castle.Core.Logging.LoggerLevel,System.String,System.String,System.Exception)">
      <summary>
              Implementors output the log content by implementing this method only.
              Note that exception can be null
            </summary>
      <param name="loggerLevel">
      </param>
      <param name="loggerName">
      </param>
      <param name="message">
      </param>
      <param name="exception">
      </param>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.Level">
      <value>
              The <c>LoggerLevel</c> that this logger
              will be using. Defaults to <c>LoggerLevel.Off</c></value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.Name">
      <value>
              The name that this logger will be using. 
              Defaults to <c>String.Empty</c></value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsDebugEnabled">
      <summary>
              Determines if messages of priority "debug" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Debug" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsInfoEnabled">
      <summary>
              Determines if messages of priority "info" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Info" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsWarnEnabled">
      <summary>
              Determines if messages of priority "warn" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Warn" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsErrorEnabled">
      <summary>
              Determines if messages of priority "error" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Error" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsFatalEnabled">
      <summary>
              Determines if messages of priority "fatal" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Fatal" /> bit</value>
    </member>
    <member name="T:Castle.Core.Logging.ConsoleLogger">
      <summary>
            The Logger sending everything to the standard output streams.
            This is mainly for the cases when you have a utility that
            does not have a logger to supply.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor">
      <summary>
              Creates a new ConsoleLogger with the <c>Level</c>
              set to <c>LoggerLevel.Debug</c> and the <c>Name</c>
              set to <c>String.Empty</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new ConsoleLogger with the <c>Name</c>
              set to <c>String.Empty</c>.
            </summary>
      <param name="logLevel">The logs Level.</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(System.String)">
      <summary>
              Creates a new ConsoleLogger with the <c>Level</c>
              set to <c>LoggerLevel.Debug</c>.
            </summary>
      <param name="name">The logs Name.</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
              Creates a new ConsoleLogger.
            </summary>
      <param name="name">The logs Name.</param>
      <param name="logLevel">The logs Level.</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.Log(Castle.Core.Logging.LoggerLevel,System.String,System.String,System.Exception)">
      <summary>
              A Common method to log.
            </summary>
      <param name="loggerLevel">The level of logging</param>
      <param name="loggerName">The name of the logger</param>
      <param name="message">The Message</param>
      <param name="exception">The Exception</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.CreateChildLogger(System.String)">
      <summary>
              Returns a new <c>ConsoleLogger</c> with the name
              added after this loggers name, with a dot in between.
            </summary>
      <param name="loggerName">The added hierarchical name.</param>
      <returns>A new <c>ConsoleLogger</c>.</returns>
    </member>
    <member name="T:Castle.Core.Logging.DiagnosticsLogger">
      <summary>
              The Logger using standart Diagnostics namespace.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String)">
      <summary>
              Creates a logger based on <see cref="T:System.Diagnostics.EventLog" />.
            </summary>
      <param name="logName">
        <see cref="P:System.Diagnostics.EventLog.Log" />
      </param>
    </member>
    <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String,System.String)">
      <summary>
              Creates a logger based on <see cref="T:System.Diagnostics.EventLog" />.
            </summary>
      <param name="logName">
        <see cref="P:System.Diagnostics.EventLog.Log" />
      </param>
      <param name="source">
        <see cref="P:System.Diagnostics.EventLog.Source" />
      </param>
    </member>
    <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String,System.String,System.String)">
      <summary>
              Creates a logger based on <see cref="T:System.Diagnostics.EventLog" />.
            </summary>
      <param name="logName">
        <see cref="P:System.Diagnostics.EventLog.Log" />
      </param>
      <param name="machineName">
        <see cref="P:System.Diagnostics.EventLog.MachineName" />
      </param>
      <param name="source">
        <see cref="P:System.Diagnostics.EventLog.Source" />
      </param>
    </member>
    <member name="T:Castle.Core.Logging.NullLogger">
      <summary>
              The Null Logger class.  This is useful for implementations where you need
              to provide a logger to a utility class, but do not want any output from it.
              It also helps when you have a utility that does not have a logger to supply.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.CreateChildLogger(System.String)">
      <summary>
              Returns this <c>NullLogger</c>.
            </summary>
      <param name="loggerName">Ignored</param>
      <returns>This ILogger instance.</returns>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String)">
      <summary>
              No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String,System.Exception)">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.Exception,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Error(System.String)">
      <summary>
              No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Error(System.String,System.Exception)">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.Exception,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String)">
      <summary>
              No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String,System.Exception)">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.Exception,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Info(System.String)">
      <summary>
              No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Info(System.String,System.Exception)">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.Exception,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String)">
      <summary>
              No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String,System.Exception)">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.Exception,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
              No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.GlobalProperties">
      <summary>
              Returns empty context properties.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.ThreadProperties">
      <summary>
              Returns empty context properties.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.ThreadStacks">
      <summary>
              Returns empty context stacks.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsDebugEnabled">
      <summary>
              No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsErrorEnabled">
      <summary>
              No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsFatalEnabled">
      <summary>
              No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsInfoEnabled">
      <summary>
              No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsWarnEnabled">
      <summary>
              No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="T:Castle.Core.Logging.StreamLogger">
      <summary>
            The Stream Logger class.  This class can stream log information
            to any stream, it is suitable for storing a log file to disk,
            or to a <c>MemoryStream</c> for testing your components.
            </summary>
      <remarks>
            This logger is not thread safe.
            </remarks>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream)">
      <summary>
              Creates a new <c>StreamLogger</c> with default encoding 
              and buffer size. Initial Level is set to Debug.
            </summary>
      <param name="name">
              The name of the log.
            </param>
      <param name="stream">
              The stream that will be used for logging,
              seeking while the logger is alive 
            </param>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream,System.Text.Encoding)">
      <summary>
              Creates a new <c>StreamLogger</c> with default buffer size.
              Initial Level is set to Debug.
            </summary>
      <param name="name">
              The name of the log.
            </param>
      <param name="stream">
              The stream that will be used for logging,
              seeking while the logger is alive 
            </param>
      <param name="encoding">
              The encoding that will be used for this stream.
              <see cref="T:System.IO.StreamWriter" /></param>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream,System.Text.Encoding,System.Int32)">
      <summary>
              Creates a new <c>StreamLogger</c>. 
              Initial Level is set to Debug.
            </summary>
      <param name="name">
              The name of the log.
            </param>
      <param name="stream">
              The stream that will be used for logging,
              seeking while the logger is alive 
            </param>
      <param name="encoding">
              The encoding that will be used for this stream.
              <see cref="T:System.IO.StreamWriter" /></param>
      <param name="bufferSize">
              The buffer size that will be used for this stream.
              <see cref="T:System.IO.StreamWriter" /></param>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.StreamWriter)">
      <summary>
              Creates a new <c>StreamLogger</c> with 
              Debug as default Level.
            </summary>
      <param name="name">The name of the log.</param>
      <param name="writer">The <c>StreamWriter</c> the log will write to.</param>
    </member>
    <member name="T:Castle.Core.Logging.TraceLogger">
      <summary>
              The TraceLogger sends all logging to the System.Diagnostics.TraceSource
              built into the .net framework.
            </summary>
      <remarks>
              Logging can be configured in the system.diagnostics configuration 
              section. 
            
              If logger doesn't find a source name with a full match it will
              use source names which match the namespace partially. For example you can
              configure from all castle components by adding a source name with the
              name "Castle". 
            
              If no portion of the namespace matches the source named "Default" will
              be used.
            </remarks>
    </member>
    <member name="M:Castle.Core.Logging.TraceLogger.#ctor(System.String)">
      <summary>
            Build a new trace logger based on the named TraceSource
            </summary>
      <param name="name">The name used to locate the best TraceSource. In most cases comes from the using type's fullname.</param>
    </member>
    <member name="M:Castle.Core.Logging.TraceLogger.#ctor(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Build a new trace logger based on the named TraceSource
            </summary>
      <param name="name">The name used to locate the best TraceSource. In most cases comes from the using type's fullname.</param>
      <param name="level">The default logging level at which this source should write messages. In almost all cases this
            default value will be overridden in the config file. </param>
    </member>
    <member name="M:Castle.Core.Logging.TraceLogger.CreateChildLogger(System.String)">
      <summary>
            Create a new child logger.
            The name of the child logger is [current-loggers-name].[passed-in-name]
            </summary>
      <param name="loggerName">The Subname of this logger.</param>
      <returns>The New ILogger instance.</returns>
    </member>
    <member name="T:Castle.Core.Configuration.IConfiguration">
      <summary>
        <see cref="T:Castle.Core.Configuration.IConfiguration" /> is a interface encapsulating a configuration node
            used to retrieve configuration values.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.IConfiguration.GetValue(System.Type,System.Object)">
      <summary>
            Gets the value of the node and converts it 
            into specified <see cref="T:System.Type" />.
            </summary>
      <param name="type">The <see cref="T:System.Type" /></param>
      <param name="defaultValue">
            The Default value returned if the conversion fails.
            </param>
      <returns>The Value converted into the specified type.</returns>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Name">
      <summary>
            Gets the name of the node.
            </summary>
      <value>
            The Name of the node.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Value">
      <summary>
            Gets the value of the node.
            </summary>
      <value>
            The Value of the node.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Children">
      <summary>
            Gets an <see cref="T:Castle.Core.Configuration.ConfigurationCollection" /> of <see cref="T:Castle.Core.Configuration.IConfiguration" />
            elements containing all node children.
            </summary>
      <value>The Collection of child nodes.</value>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Attributes">
      <summary>
            Gets an <see cref="T:System.Collections.IDictionary" /> of the configuration attributes.
            </summary>
    </member>
    <member name="T:Castle.Core.Configuration.AbstractConfiguration">
      <summary>
              This is an abstract <see cref="T:Castle.Core.Configuration.IConfiguration" /> implementation
              that deals with methods that can be abstracted away
              from underlying implementations.
            </summary>
      <remarks>
        <para>
          <b>AbstractConfiguration</b> makes easier to implementers 
                to create a new version of <see cref="T:Castle.Core.Configuration.IConfiguration" /></para>
      </remarks>
    </member>
    <member name="M:Castle.Core.Configuration.AbstractConfiguration.GetValue(System.Type,System.Object)">
      <summary>
              Gets the value of the node and converts it
              into specified <see cref="T:System.Type" />.
            </summary>
      <param name="type">The <see cref="T:System.Type" /></param>
      <param name="defaultValue">
              The Default value returned if the conversion fails.
            </param>
      <returns>The Value converted into the specified type.</returns>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Attributes">
      <summary>
              Gets node attributes.
            </summary>
      <value>
              All attributes of the node.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Children">
      <summary>
              Gets all child nodes.
            </summary>
      <value>The <see cref="T:Castle.Core.Configuration.ConfigurationCollection" /> of child nodes.</value>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Name">
      <summary>
              Gets the name of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <value>
              The Name of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Value">
      <summary>
              Gets the value of <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <value>
              The Value of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </value>
    </member>
    <member name="T:Castle.Core.Configuration.ConfigurationCollection">
      <summary>
            A collection of <see cref="T:Castle.Core.Configuration.IConfiguration" /> objects.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.#ctor">
      <summary>
            Creates a new instance of <c>ConfigurationCollection</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.#ctor(System.Collections.Generic.IEnumerable{Castle.Core.Configuration.IConfiguration})">
      <summary>
            Creates a new instance of <c>ConfigurationCollection</c>.
            </summary>
    </member>
    <member name="T:Castle.Core.Configuration.MutableConfiguration">
      <summary>
            Summary description for MutableConfiguration.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.MutableConfiguration.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.Configuration.MutableConfiguration" /> class.
            </summary>
      <param name="name">The name.</param>
    </member>
    <member name="P:Castle.Core.Configuration.MutableConfiguration.Value">
      <summary>
            Gets the value of <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <value>
            The Value of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </value>
    </member>
    <member name="M:Castle.Core.Configuration.Xml.XmlConfigurationDeserializer.Deserialize(System.Xml.XmlNode)">
      <summary>
              Deserializes the specified node into an abstract representation of configuration.
            </summary>
      <param name="node">The node.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Configuration.Xml.XmlConfigurationDeserializer.GetConfigValue(System.String)">
      <summary>
              If a config value is an empty string we return null, this is to keep
              backward compatibility with old code
            </summary>
    </member>
    <member name="T:Castle.Core.Pair`2">
      <summary>
            General purpose class to represent a standard pair of values. 
            </summary>
      <typeparam name="TFirst">Type of the first value</typeparam>
      <typeparam name="TSecond">Type of the second value</typeparam>
    </member>
    <member name="M:Castle.Core.Pair`2.#ctor(`0,`1)">
      <summary>
            Constructs a pair with its values
            </summary>
      <param name="first">
      </param>
      <param name="second">
      </param>
    </member>
    <member name="T:Castle.Core.ProxyServices">
      <summary>
            List of utility methods related to dynamic proxy operations
            </summary>
    </member>
    <member name="M:Castle.Core.ProxyServices.IsDynamicProxy(System.Type)">
      <summary>
            Determines whether the specified type is a proxy generated by
            DynamicProxy (1 or 2).
            </summary>
      <param name="type">The type.</param>
      <returns>
        <c>true</c> if it is a proxy; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Castle.Core.ReflectionBasedDictionaryAdapter">
      <summary>
            Readonly implementation of <see cref="T:System.Collections.IDictionary" /> which uses an anonymous object as its source. Uses names of properties as keys, and property values as... well - values. Keys are not case sensitive.
            </summary>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.#ctor(System.Object)">
      <summary>
              Initializes a new instance of the <see cref="T:Castle.Core.ReflectionBasedDictionaryAdapter" /> class.
            </summary>
      <param name="target">The target.</param>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Add(System.Object,System.Object)">
      <summary>
              Adds an element with the provided key and value to the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <param name="key">The <see cref="T:System.Object" /> to use as the key of the element to add.</param>
      <param name="value">The <see cref="T:System.Object" /> to use as the value of the element to add.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null. </exception>
      <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.IDictionary" /> object. </exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary" /> is read-only.-or- The <see cref="T:System.Collections.IDictionary" /> has a fixed size. </exception>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Clear">
      <summary>
              Removes all elements from the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary" /> object is read-only. </exception>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Contains(System.Object)">
      <summary>
              Determines whether the <see cref="T:System.Collections.IDictionary" /> object contains an element with the specified key.
            </summary>
      <param name="key">The key to locate in the <see cref="T:System.Collections.IDictionary" /> object.</param>
      <returns>
              true if the <see cref="T:System.Collections.IDictionary" /> contains an element with the key; otherwise, false.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null. </exception>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Remove(System.Object)">
      <summary>
              Removes the element with the specified key from the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <param name="key">The key of the element to remove.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null. </exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary" /> object is read-only.-or- The <see cref="T:System.Collections.IDictionary" /> has a fixed size. </exception>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.GetEnumerator">
      <summary>
              Returns an enumerator that iterates through a collection.
            </summary>
      <returns>
              An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Read(System.Collections.IDictionary,System.Object)">
      <summary>
              Reads values of properties from <paramref name="valuesAsAnonymousObject" /> and inserts them into <paramref name="targetDictionary" /> using property names as keys.
            </summary>
      <param name="targetDictionary">
      </param>
      <param name="valuesAsAnonymousObject">
      </param>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Count">
      <summary>
              Gets the number of elements contained in the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
      <returns>The number of elements contained in the <see cref="T:System.Collections.ICollection" />.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.IsSynchronized">
      <summary>
              Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe).
            </summary>
      <value>
      </value>
      <returns>true if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe); otherwise, false.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.SyncRoot">
      <summary>
              Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
      <returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.IsReadOnly">
      <summary>
              Gets a value indicating whether the <see cref="T:System.Collections.IDictionary" /> object is read-only.
            </summary>
      <value>
      </value>
      <returns>true if the <see cref="T:System.Collections.IDictionary" /> object is read-only; otherwise, false.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Item(System.Object)">
      <summary>
              Gets or sets the <see cref="T:System.Object" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Keys">
      <summary>
              Gets an <see cref="T:System.Collections.ICollection" /> object containing the keys of the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <value>
      </value>
      <returns>An <see cref="T:System.Collections.ICollection" /> object containing the keys of the <see cref="T:System.Collections.IDictionary" /> object.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Values">
      <summary>
              Gets an <see cref="T:System.Collections.ICollection" /> object containing the values in the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <value>
      </value>
      <returns>An <see cref="T:System.Collections.ICollection" /> object containing the values in the <see cref="T:System.Collections.IDictionary" /> object.</returns>
    </member>
    <member name="T:Castle.Core.Resource.IResource">
      <summary>
            Represents a 'streamable' resource. Can
            be a file, a resource in an assembly.
            </summary>
    </member>
    <member name="M:Castle.Core.Resource.IResource.GetStreamReader">
      <summary>
            Returns a reader for the stream
            </summary>
      <remarks>
            It's up to the caller to dispose the reader.
            </remarks>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResource.GetStreamReader(System.Text.Encoding)">
      <summary>
            Returns a reader for the stream
            </summary>
      <remarks>
            It's up to the caller to dispose the reader.
            </remarks>
      <param name="encoding">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResource.CreateRelative(System.String)">
      <summary>
            Returns an instance of <see cref="T:Castle.Core.Resource.IResource" />
            created according to the <c>relativePath</c>
            using itself as the root.
            </summary>
      <param name="relativePath">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Core.Resource.IResource.FileBasePath">
      <summary>
      </summary>
      <remarks>
            Only valid for resources that
            can be obtained through relative paths
            </remarks>
    </member>
    <member name="T:Castle.Core.Resource.AbstractStreamResource">
      <summary>
      </summary>
    </member>
    <member name="F:Castle.Core.Resource.AbstractStreamResource.createStream">
      <summary>
            This returns a new stream instance each time it is called.
            It is the responsibility of the caller to dispose of this stream
            </summary>
    </member>
    <member name="T:Castle.Core.Resource.IResourceFactory">
      <summary>
            Depicts the contract for resource factories.
            </summary>
    </member>
    <member name="M:Castle.Core.Resource.IResourceFactory.Accept(Castle.Core.Resource.CustomUri)">
      <summary>
            Used to check whether the resource factory
            is able to deal with the given resource
            identifier.
            </summary>
      <remarks>
            Implementors should return <c>true</c>
            only if the given identifier is supported
            by the resource factory
            </remarks>
      <param name="uri">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResourceFactory.Create(Castle.Core.Resource.CustomUri)">
      <summary>
            Creates an <see cref="T:Castle.Core.Resource.IResource" /> instance
            for the given resource identifier
            </summary>
      <param name="uri">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResourceFactory.Create(Castle.Core.Resource.CustomUri,System.String)">
      <summary>
            Creates an <see cref="T:Castle.Core.Resource.IResource" /> instance
            for the given resource identifier
            </summary>
      <param name="uri">
      </param>
      <param name="basePath">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Resource.FileResource">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Core.Resource.FileResourceFactory">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Core.Resource.StaticContentResource">
      <summary>
            Adapts a static string content as an <see cref="T:Castle.Core.Resource.IResource" /></summary>
    </member>
    <member name="T:Castle.Core.Resource.UncResource">
      <summary>
            Enable access to files on network shares
            </summary>
    </member>
    <member name="T:Castle.Core.Smtp.IEmailSender">
      <summary>
            Email sender abstraction.
            </summary>
    </member>
    <member name="M:Castle.Core.Smtp.IEmailSender.Send(System.String,System.String,System.String,System.String)">
      <summary>
            Sends a mail message.
            </summary>
      <param name="from">From field</param>
      <param name="to">To field</param>
      <param name="subject">E-mail's subject</param>
      <param name="messageText">message's body</param>
    </member>
    <member name="M:Castle.Core.Smtp.IEmailSender.Send(System.Net.Mail.MailMessage)">
      <summary>
            Sends a <see cref="T:System.Net.Mail.MailMessage">message</see>. 
            </summary>
      <param name="message">
        <see cref="T:System.Net.Mail.MailMessage">Message</see> instance</param>
    </member>
    <member name="M:Castle.Core.Smtp.IEmailSender.Send(System.Collections.Generic.IEnumerable{System.Net.Mail.MailMessage})">
      <summary>
            Sends multiple <see cref="T:System.Net.Mail.MailMessage">messages</see>. 
            </summary>
      <param name="messages">List of <see cref="T:System.Net.Mail.MailMessage">messages</see></param>
    </member>
    <member name="T:Castle.Core.Smtp.DefaultSmtpSender">
      <summary>
            Default <see cref="T:Castle.Core.Smtp.IEmailSender" /> implementation.
            </summary>
    </member>
    <member name="M:Castle.Core.Smtp.DefaultSmtpSender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.Smtp.DefaultSmtpSender" /> class based on the <see cref="T:System.Net.Mail.SmtpClient" /> configuration provided in the application configuration file.
            </summary>
      <remarks>
            This constructor is based on the default <see cref="T:System.Net.Mail.SmtpClient" /> configuration in the application configuration file.
            </remarks>
    </member>
    <member name="M:Castle.Core.Smtp.DefaultSmtpSender.#ctor(System.String)">
      <summary>
            This service implementation
            requires a host name in order to work
            </summary>
      <param name="hostname">The smtp server name</param>
    </member>
    <member name="M:Castle.Core.Smtp.DefaultSmtpSender.Send(System.String,System.String,System.String,System.String)">
      <summary>
            Sends a message. 
            </summary>
      <exception cref="T:System.ArgumentNullException">If any of the parameters is null</exception>
      <param name="from">From field</param>
      <param name="to">To field</param>
      <param name="subject">e-mail's subject</param>
      <param name="messageText">message's body</param>
    </member>
    <member name="M:Castle.Core.Smtp.DefaultSmtpSender.Send(System.Net.Mail.MailMessage)">
      <summary>
            Sends a message. 
            </summary>
      <exception cref="T:System.ArgumentNullException">If the message is null</exception>
      <param name="message">Message instance</param>
    </member>
    <member name="M:Castle.Core.Smtp.DefaultSmtpSender.Configure(System.Net.Mail.SmtpClient)">
      <summary>
            Configures the sender
            with port information and eventual credential
            informed
            </summary>
      <param name="smtpClient">Message instance</param>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.Port">
      <summary>
            Gets or sets the port used to 
            access the SMTP server
            </summary>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.Hostname">
      <summary>
            Gets the hostname.
            </summary>
      <value>The hostname.</value>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.AsyncSend">
      <summary>
            Gets or sets a value which is used to 
            configure if emails are going to be sent asynchronously or not.
            </summary>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.Timeout">
      <summary>
            Gets or sets a value that specifies 
            the amount of time after which a synchronous Send call times out.
            </summary>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.UseSsl">
      <summary>
            Gets or sets a value indicating whether the email should be sent using 
            a secure communication channel.
            </summary>
      <value>
        <c>true</c> if should use SSL; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.Domain">
      <summary>
            Gets or sets the domain.
            </summary>
      <value>The domain.</value>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.UserName">
      <summary>
            Gets or sets the name of the user.
            </summary>
      <value>The name of the user.</value>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.Password">
      <summary>
            Gets or sets the password.
            </summary>
      <value>The password.</value>
    </member>
    <member name="P:Castle.Core.Smtp.DefaultSmtpSender.HasCredentials">
      <summary>
            Gets a value indicating whether credentials were informed.
            </summary>
      <value>
        <see langword="true" /> if this instance has credentials; otherwise, <see langword="false" />.
            </value>
    </member>
  </members>
</doc>